## API Report File for "@microsoft/teamsfx-api"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { IBot } from '@microsoft/teams-manifest';
import { IComposeExtension } from '@microsoft/teams-manifest';
import { IConfigurableTab } from '@microsoft/teams-manifest';
import { IStaticTab } from '@microsoft/teams-manifest';
import { IWebApplicationInfo } from '@microsoft/teams-manifest';
import { Result } from 'neverthrow';
import { TokenCredential } from '@azure/core-http';

// @public (undocumented)
interface AADApp extends AzureResource {
    // (undocumented)
    applicationIdUris: string;
    // (undocumented)
    clientId: string;
    // (undocumented)
    clientSecret: string;
    // (undocumented)
    oauth2PermissionScopeId: string;
    // (undocumented)
    oauthAuthority: string;
    // (undocumented)
    oauthHost: string;
    // (undocumented)
    objectId: string;
    // (undocumented)
    secretFields: "clientSecret"[];
    // (undocumented)
    tenantId: string;
}

// @public (undocumented)
export type Action = GroupAction | ShellAction | CallAction | FunctionAction;

// @public
export interface ActionBase {
    condition?: (context: ContextV3, inputs: InputsWithProjectPath) => MaybePromise<Result<boolean, FxError>>;
    // (undocumented)
    exception?: (context: ContextV3, inputs: InputsWithProjectPath) => MaybePromise<Result<undefined, FxError>>;
    // (undocumented)
    inputs?: Json;
    // (undocumented)
    name?: string;
    // (undocumented)
    plan?: (context: ContextV3, inputs: InputsWithProjectPath) => MaybePromise<Result<Effect[], FxError>>;
    // (undocumented)
    post?: (context: ContextV3, inputs: InputsWithProjectPath) => MaybePromise<Result<undefined, FxError>>;
    // (undocumented)
    pre?: (context: ContextV3, inputs: InputsWithProjectPath) => MaybePromise<Result<undefined, FxError>>;
    // (undocumented)
    question?: (context: ContextV3, inputs: InputsWithProjectPath) => MaybePromise<Result<QTreeNode | undefined, FxError>>;
    // (undocumented)
    type: "group" | "shell" | "call" | "function";
}

// @public (undocumented)
export interface ActionContext {
    // (undocumented)
    progressBar?: IProgressHandler;
    // (undocumented)
    telemetryProps?: Record<string, string>;
}

// @public (undocumented)
export const AdaptiveCardsFolderName = "adaptiveCards";

// @public (undocumented)
interface AddFeatureInputs extends InputsWithProjectPath {
    // (undocumented)
    allPluginsAfterAdd: string[];
}

// @public (undocumented)
interface APIM extends AzureResource {
    // (undocumented)
    apimClientAADClientId: string;
    // (undocumented)
    apimClientAADClientSecret: string;
    // (undocumented)
    apimClientAADObjectId: string;
    // (undocumented)
    authServerResourceId: string;
    // (undocumented)
    productResourceId: string;
    // (undocumented)
    secretFields: "apimClientAADClientSecret"[];
    // (undocumented)
    serviceResourceId: string;
}

// @public (undocumented)
interface AppManifestProvider {
    // (undocumented)
    addCapabilities: (ctx: Context_2, inputs: InputsWithProjectPath, capabilities: ManifestCapability[]) => Promise<Result<Void, FxError>>;
    // (undocumented)
    capabilityExceedLimit: (ctx: Context_2, inputs: InputsWithProjectPath, capability: "staticTab" | "configurableTab" | "Bot" | "MessageExtension" | "WebApplicationInfo") => Promise<Result<boolean, FxError>>;
    // (undocumented)
    deleteCapability: (ctx: Context_2, inputs: InputsWithProjectPath, capability: ManifestCapability) => Promise<Result<Void, FxError>>;
    // (undocumented)
    updateCapability: (ctx: Context_2, inputs: InputsWithProjectPath, capability: ManifestCapability) => Promise<Result<Void, FxError>>;
}

// @public (undocumented)
export const AppPackageFolderName = "appPackage";

// @public (undocumented)
export function assembleError(e: any, source?: string): FxError;

// @public (undocumented)
export const AutoGeneratedReadme = "README-auto-generated.md";

// @public
export interface AzureAccountProvider {
    getAccountInfo(): Record<string, string> | undefined;
    getIdentityCredentialAsync(showDialog?: boolean): Promise<TokenCredential | undefined>;
    getJsonObject(showDialog?: boolean): Promise<Record<string, unknown> | undefined>;
    getSelectedSubscription(triggerUI?: boolean): Promise<SubscriptionInfo | undefined>;
    listSubscriptions(): Promise<SubscriptionInfo[]>;
    removeStatusChangeMap(name: string): Promise<boolean>;
    setStatusChangeMap(name: string, statusChange: (status: string, token?: string, accountInfo?: Record<string, unknown>) => Promise<void>, immediateCall?: boolean): Promise<boolean>;
    setSubscription(subscriptionId: string): Promise<void>;
    signout(): Promise<boolean>;
}

// @public (undocumented)
interface AzureBot extends AzureResource {
    // (undocumented)
    appServicePlanName: string;
    // (undocumented)
    botId: string;
    // (undocumented)
    botPassword: string;
    // (undocumented)
    botWebAppResourceId: string;
    // (undocumented)
    objectId: string;
    // (undocumented)
    secretFields: "botPassword"[];
    // (undocumented)
    siteEndpoint: string;
    // (undocumented)
    siteName: string;
    // (undocumented)
    skuName: string;
    // (undocumented)
    validDomain: string;
}

// @public (undocumented)
interface AzureFunction extends AzureResource {
    // (undocumented)
    functionAppResourceId: string;
    // (undocumented)
    functionEndpoint: string;
}

// @public (undocumented)
interface AzureIdentity extends AzureResource {
    // (undocumented)
    identityClientId: string;
    // (undocumented)
    identityName: string;
    // (undocumented)
    identityResourceId: string;
}

// @public (undocumented)
type AzureResource = CloudResource_2;

// @public (undocumented)
interface AzureResourcePlugin {
    addInstance?: (ctx: ContextWithManifestProvider, inputs: InputsWithProjectPath) => Promise<Result<string[], FxError>>;
    configureResource?: (ctx: Context_2, inputs: InputsWithProjectPath, envInfo: EnvInfoV3, tokenProvider: TokenProvider) => Promise<Result<Void, FxError>>;
    deploy?: (ctx: Context_2, inputs: InputsWithProjectPath, envInfo: DeepReadonly<EnvInfoV3>, tokenProvider: TokenProvider) => Promise<Result<Void, FxError>>;
    description?: string;
    displayName?: string;
    generateBicep?: (ctx: ContextWithManifestProvider, inputs: AddFeatureInputs) => Promise<Result<BicepTemplate_2[], FxError>>;
    generateCode?: (ctx: ContextWithManifestProvider, inputs: AddFeatureInputs) => Promise<Result<Void, FxError>>;
    getQuestionsForAddInstance?: (ctx: Context_2, inputs: Inputs) => Promise<Result<QTreeNode | undefined, FxError>>;
    getQuestionsForDeploy?: (ctx: Context_2, inputs: Inputs, envInfo: DeepReadonly<EnvInfoV3>, tokenProvider: TokenProvider) => Promise<Result<QTreeNode | undefined, FxError>>;
    getQuestionsForProvision?: (ctx: Context_2, inputs: Inputs, envInfo: DeepReadonly<EnvInfoV3>, tokenProvider: TokenProvider) => Promise<Result<QTreeNode | undefined, FxError>>;
    name: string;
    provisionResource?: (ctx: Context_2, inputs: InputsWithProjectPath, envInfo: EnvInfoV3, tokenProvider: TokenProvider) => Promise<Result<Void, FxError>>;
    updateBicep?: (ctx: ContextWithManifestProvider, inputs: UpdateInputs) => Promise<Result<BicepTemplate_2[], FxError>>;
}

// @public
interface AzureSolutionConfig extends Json {
    // (undocumented)
    location: string;
    // (undocumented)
    needCreateResourceGroup: boolean;
    // (undocumented)
    provisionSucceeded: boolean;
    // (undocumented)
    resourceGroupName: string;
    // (undocumented)
    resourceNameSuffix: string;
    // (undocumented)
    subscriptionId: string;
    // (undocumented)
    subscriptionName: string;
    // (undocumented)
    teamsAppTenantId: string;
    // (undocumented)
    tenantId: string;
}

// @public (undocumented)
export interface AzureSolutionSettings extends SolutionSettings {
    // (undocumented)
    activeResourcePlugins: string[];
    // (undocumented)
    azureResources: string[];
    // (undocumented)
    capabilities: string[];
    // (undocumented)
    hostType: string;
}

// @public (undocumented)
interface AzureSQL extends AzureResource {
    // (undocumented)
    admin: string;
    // (undocumented)
    databaseName: string;
    // (undocumented)
    sqlEndpoint: string;
    // (undocumented)
    sqlResourceId: string;
}

// @public
export interface BaseQuestion {
    buttons?: {
        icon: string;
        tooltip: string;
        command: string;
    }[];
    default?: unknown;
    forgetLastValue?: boolean;
    name: string;
    step?: number;
    title?: string;
    totalSteps?: number;
    value?: unknown;
}

// @public
export abstract class BasicLogin {
    // (undocumented)
    abstract getStatus(tokenRequest: TokenRequest): Promise<Result<LoginStatus, FxError>>;
    // (undocumented)
    notifyStatus(tokenRequest: TokenRequest): Promise<void>;
    // (undocumented)
    removeStatusChangeMap(name: string): Promise<Result<boolean, FxError>>;
    // (undocumented)
    setStatusChangeMap(name: string, tokenRequest: TokenRequest, statusChange: (status: string, token?: string, accountInfo?: Record<string, unknown>) => Promise<void>, immediateCall?: boolean): Promise<Result<boolean, FxError>>;
    // (undocumented)
    statusChangeMap: Map<any, any>;
}

// @public (undocumented)
export interface Bicep {
    // (undocumented)
    Configuration?: ConfigurationBicep;
    // (undocumented)
    Parameters?: Record<string, string>;
    // (undocumented)
    Provision?: ProvisionBicep;
    // (undocumented)
    type: "bicep";
}

// @public (undocumented)
type BicepTemplate = {
    kind: "bicep";
    template: Record<string, unknown>;
};

// @public (undocumented)
interface BicepTemplate_2 extends Record<any, unknown> {
    // (undocumented)
    Configuration?: {
        Orchestration?: string;
        Modules?: {
            [moduleFileName: string]: string;
        };
    };
    // (undocumented)
    Parameters?: Record<string, string>;
    // (undocumented)
    Provision?: {
        Orchestration?: string;
        Modules?: {
            [moduleFileName: string]: string;
        };
    };
    // (undocumented)
    Reference?: Record<string, unknown>;
}

// @public (undocumented)
export const BuildFolderName = "build";

// @public
export interface CallAction extends ActionBase {
    // (undocumented)
    required: boolean;
    // (undocumented)
    targetAction: string;
    // (undocumented)
    type: "call";
}

// @public (undocumented)
export interface CallServiceEffect {
    // (undocumented)
    name: string;
    // (undocumented)
    remarks?: string;
    // (undocumented)
    response?: string;
    // (undocumented)
    type: "service";
}

// @public (undocumented)
export const CLIPlatforms: Platform[];

// @public (undocumented)
export interface CloudResource {
    // (undocumented)
    configure?: (context: ResourceContextV3, inputs: InputsWithProjectPath, actionContext?: ActionContext) => Promise<Result<undefined, FxError>>;
    // (undocumented)
    deploy?: (context: ResourceContextV3, inputs: InputsWithProjectPath, actionContext?: ActionContext) => Promise<Result<undefined, FxError>>;
    // (undocumented)
    readonly description?: string;
    // (undocumented)
    readonly finalOutputKeys: string[];
    // (undocumented)
    generateBicep?: (context: ContextV3, inputs: InputsWithProjectPath, actionContext?: ActionContext) => Promise<Result<Bicep[], FxError>>;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly outputs: ResourceOutputs;
    // (undocumented)
    provision?: (context: ResourceContextV3, inputs: InputsWithProjectPath, actionContext?: ActionContext) => Promise<Result<undefined, FxError>>;
    // (undocumented)
    readonly secretKeys?: string[];
}

// @public (undocumented)
interface CloudResource_2 extends Json {
    endpoint?: string | string[];
    resourceId?: string;
    resourceName?: string;
    secretFields?: string[];
}

// @public
export enum Colors {
    BRIGHT_CYAN = 6,
    BRIGHT_GREEN = 3,
    BRIGHT_MAGENTA = 2,
    BRIGHT_RED = 5,
    BRIGHT_WHITE = 0,
    BRIGHT_YELLOW = 4,
    WHITE = 1
}

// @public (undocumented)
export interface Component extends Json {
    // (undocumented)
    artifactFolder?: string;
    // (undocumented)
    build?: boolean;
    // (undocumented)
    code?: string;
    // (undocumented)
    connections?: string[];
    // (undocumented)
    deploy?: boolean;
    // (undocumented)
    deployType?: "folder" | "zip";
    // (undocumented)
    folder?: string;
    // (undocumented)
    hosting?: string;
    // (undocumented)
    language?: string;
    // (undocumented)
    name: string;
    // (undocumented)
    provision?: boolean;
    // (undocumented)
    sso?: boolean;
}

// @public (undocumented)
export class ConcurrentError extends UserError {
    constructor(source: string);
}

// @public (undocumented)
export const ConfigFolderName = "fx";

// @public (undocumented)
export class ConfigMap extends Map<string, ConfigValue> {
    constructor(entries?: readonly (readonly [string, ConfigValue])[] | null);
    // (undocumented)
    static fromJSON(obj?: Json): ConfigMap | undefined;
    // (undocumented)
    getBoolean(k: string, defaultValue?: boolean): boolean | undefined;
    // (undocumented)
    getBooleanArray(k: string, defaultValue?: boolean[]): boolean[] | undefined;
    // (undocumented)
    getNumber(k: string, defaultValue?: number): number | undefined;
    // (undocumented)
    getNumberArray(k: string, defaultValue?: number[]): number[] | undefined;
    // (undocumented)
    getOptionItem(k: string, defaultValue?: OptionItem): OptionItem | undefined;
    // (undocumented)
    getOptionItemArray(k: string, defaultValue?: OptionItem[]): OptionItem[] | undefined;
    // (undocumented)
    getString(k: string, defaultValue?: string): string | undefined;
    // (undocumented)
    getStringArray(k: string, defaultValue?: string[]): string[] | undefined;
    // (undocumented)
    toJSON(): Json;
}

// @public (undocumented)
export interface ConfigurationBicep {
    // (undocumented)
    Modules?: {
        [moduleFileName: string]: string;
    };
    // (undocumented)
    Orchestration?: string;
}

// @public (undocumented)
export type ConfigValue = any;

// @public (undocumented)
export interface Context {
    // (undocumented)
    answers?: Inputs;
    // (undocumented)
    azureAccountProvider?: AzureAccountProvider;
    // (undocumented)
    cryptoProvider: CryptoProvider;
    // (undocumented)
    expServiceProvider?: ExpServiceProvider;
    // (undocumented)
    localSettings?: LocalSettings;
    // (undocumented)
    logProvider?: LogProvider;
    // (undocumented)
    m365TokenProvider?: M365TokenProvider;
    // (undocumented)
    permissionRequestProvider?: PermissionRequestProvider;
    // (undocumented)
    projectSettings?: ProjectSettings;
    // (undocumented)
    root: string;
    // (undocumented)
    telemetryReporter?: TelemetryReporter;
    // (undocumented)
    treeProvider?: TreeProvider;
    // (undocumented)
    ui?: UserInteraction;
}

// @public (undocumented)
interface Context_2 {
    // (undocumented)
    cryptoProvider: CryptoProvider;
    // (undocumented)
    expServiceProvider?: ExpServiceProvider;
    // (undocumented)
    logProvider: LogProvider;
    // (undocumented)
    permissionRequestProvider?: PermissionRequestProvider;
    // (undocumented)
    projectSetting: ProjectSettings;
    // (undocumented)
    telemetryReporter: TelemetryReporter;
    // (undocumented)
    userInteraction: UserInteraction;
}

// @public (undocumented)
export interface ContextV3 extends Context_2 {
    // (undocumented)
    envInfo?: EnvInfoV3;
    // (undocumented)
    manifestProvider: AppManifestProvider;
    // (undocumented)
    projectPath?: string;
    // (undocumented)
    projectSetting: ProjectSettingsV3;
    // (undocumented)
    tokenProvider?: TokenProvider;
}

// @public (undocumented)
interface ContextWithManifestProvider extends Context_2 {
    // (undocumented)
    appManifestProvider: AppManifestProvider;
}

// @public (undocumented)
export interface Core {
    // (undocumented)
    activateEnv: (inputs: Inputs) => Promise<Result<Void, FxError>>;
    // (undocumented)
    buildArtifacts: (inputs: Inputs) => Promise<Result<Void, FxError>>;
    // (undocumented)
    checkPermission: (inputs: Inputs) => Promise<Result<any, FxError>>;
    // (undocumented)
    createEnv: (inputs: Inputs) => Promise<Result<Void, FxError>>;
    // (undocumented)
    createProject: (inputs: Inputs) => Promise<Result<string, FxError>>;
    // (undocumented)
    decrypt: (ciphertext: string, inputs: Inputs) => Promise<Result<string, FxError>>;
    // (undocumented)
    deployArtifacts: (inputs: Inputs) => Promise<Result<Void, FxError>>;
    encrypt: (plaintext: string, inputs: Inputs) => Promise<Result<string, FxError>>;
    // (undocumented)
    executeUserTask: (func: Func, inputs: Inputs) => Promise<Result<unknown, FxError>>;
    getQuestions: (task: Stage, inputs: Inputs) => Promise<Result<QTreeNode | undefined, FxError>>;
    // (undocumented)
    getQuestionsForUserTask?: (router: FunctionRouter, inputs: Inputs) => Promise<Result<QTreeNode | undefined, FxError>>;
    grantPermission: (inputs: Inputs) => Promise<Result<any, FxError>>;
    // (undocumented)
    listCollaborator: (inputs: Inputs) => Promise<Result<any, FxError>>;
    // (undocumented)
    localDebug: (inputs: Inputs) => Promise<Result<Void, FxError>>;
    on: (event: CoreCallbackEvent, callback: CoreCallbackFunc) => void;
    // (undocumented)
    provisionResources: (inputs: Inputs) => Promise<Result<Void, FxError>>;
    // (undocumented)
    publishApplication: (inputs: Inputs) => Promise<Result<Void, FxError>>;
    // (undocumented)
    version?: string;
}

// @public
export enum CoreCallbackEvent {
    // (undocumented)
    lock = "lock",
    // (undocumented)
    unlock = "unlock"
}

// @public (undocumented)
export type CoreCallbackFunc = (err?: FxError, data?: any) => void;

// @public
export interface CryptoProvider {
    decrypt(ciphertext: string): Result<string, FxError>;
    encrypt(plaintext: string): Result<string, FxError>;
}

// @public (undocumented)
type DeepReadonly<T> = {
    readonly [P in keyof T]: DeepReadonly<T[P]>;
};

// @public (undocumented)
export const DefaultReadme = "README.md";

// @public (undocumented)
type DeploymentInputs = InputsWithProjectPath & SolutionInputs;

// @public
export type DynamicOptions = LocalFunc<StaticOptions>;

// @public (undocumented)
export const DynamicPlatforms: Platform[];

// @public (undocumented)
export type Effect = string | FileEffect | CallServiceEffect | Bicep | ShellAction;

// @public (undocumented)
export class EmptyOptionError extends SystemError {
    constructor(source?: string);
}

// @public
export interface EnvConfig {
    // (undocumented)
    $schema?: string;
    // (undocumented)
    [k: string]: unknown;
    auth?: {
        clientId?: string;
        clientSecret?: string;
        objectId?: string;
        accessAsUserScopeId?: string;
        frontendDomain?: string;
        botId?: string;
        botEndpoint?: string;
        [k: string]: unknown;
    };
    azure?: {
        subscriptionId?: string;
        resourceGroupName?: string;
        [k: string]: unknown;
    };
    bot?: {
        appId?: string;
        appPassword?: string;
        [k: string]: unknown;
    };
    // (undocumented)
    description?: string;
    manifest: {
        appName: {
            short: string;
            full?: string;
            [k: string]: unknown;
        };
        description?: {
            short?: string;
            full?: string;
            [k: string]: unknown;
        };
        icons?: {
            color?: string;
            outline?: string;
            [k: string]: unknown;
        };
        [k: string]: unknown;
    };
    skipAddingSqlUser?: boolean;
}

// @public (undocumented)
export const EnvConfigFileNameTemplate: string;

declare namespace EnvConfigSchema {
    export {

    }
}
export { EnvConfigSchema }

// @public (undocumented)
export interface EnvInfo {
    // (undocumented)
    config: EnvConfig;
    // (undocumented)
    envName: string;
    // (undocumented)
    state: Map<string, any>;
}

// @public (undocumented)
type EnvInfoV2 = Omit<EnvInfo, "state" | "config"> & {
    state: Json;
} & {
    config: Json;
};

// @public (undocumented)
interface EnvInfoV3 extends EnvInfoV2 {
    // (undocumented)
    state: ResourceStates;
}

// @public
export interface EnvMeta {
    // (undocumented)
    local: boolean;
    // (undocumented)
    name: string;
    // (undocumented)
    sideloading: boolean;
}

// @public (undocumented)
export const EnvNamePlaceholder = "@envName";

// @public (undocumented)
export const EnvStateFileNameTemplate: string;

// @public (undocumented)
export type ErrorHandler = (error: any, telemetryProps: Record<string, string>) => FxError;

// @public (undocumented)
export interface ErrorOptionBase {
    // (undocumented)
    displayMessage?: string;
    // (undocumented)
    error?: Error;
    // (undocumented)
    message?: string;
    // (undocumented)
    name?: string;
    // (undocumented)
    source?: string;
    // (undocumented)
    userData?: any;
}

// @public
export interface ExecuteFuncConfig extends UIConfig<string> {
    // (undocumented)
    func: LocalFunc<any>;
    // (undocumented)
    inputs: Inputs;
}

// @public (undocumented)
export interface ExpServiceProvider {
    // (undocumented)
    getTreatmentVariableAsync<T extends boolean | number | string>(configId: string, name: string, checkCache?: boolean): Promise<T | undefined>;
}

// @public (undocumented)
export interface FileEffect {
    // (undocumented)
    filePath: string | string[];
    // (undocumented)
    operate: FileOperation;
    // (undocumented)
    remarks?: string;
    // (undocumented)
    type: "file";
}

// @public
export type FileOperation = "create" | "replace" | "append" | "delete" | "skipCreate" | "skipReplace";

// @public (undocumented)
export interface FolderQuestion extends UserInputQuestion {
    default?: string | LocalFunc<string | undefined>;
    // (undocumented)
    type: "folder";
    validation?: FuncValidation<string>;
    value?: string;
}

// @public (undocumented)
interface FrontendHostingResource extends AzureResource {
    // (undocumented)
    domain: string;
    // (undocumented)
    endpoint: string;
    // (undocumented)
    storageResourceId: string;
}

// @public (undocumented)
export interface Func extends FunctionRouter {
    // (undocumented)
    params?: any;
}

// @public
export interface FuncQuestion extends BaseQuestion {
    func: LocalFunc<any>;
    // (undocumented)
    type: "func";
}

// @public
export interface FunctionAction extends ActionBase {
    // (undocumented)
    enableProgressBar?: boolean;
    // (undocumented)
    enableTelemetry?: boolean;
    // (undocumented)
    errorHandler?: ErrorHandler;
    // (undocumented)
    errorHelpLink?: string;
    // (undocumented)
    errorIssueLink?: string;
    // (undocumented)
    errorSource?: string;
    execute: (context: ContextV3, inputs: InputsWithProjectPath, progress?: IProgressHandler, telemetryProps?: Record<string, string>) => MaybePromise<Result<Effect[], FxError>>;
    // (undocumented)
    name: string;
    // (undocumented)
    progressSteps?: number;
    // (undocumented)
    progressTitle?: string;
    // (undocumented)
    telemetryComponentName?: string;
    // (undocumented)
    telemetryEventName?: string;
    // (undocumented)
    telemetryProps?: Record<string, string>;
    // (undocumented)
    type: "function";
}

// @public (undocumented)
export interface FunctionRouter {
    // (undocumented)
    method: string;
    // (undocumented)
    namespace: string;
}

// @public
export interface FuncValidation<T extends string | string[] | OptionItem | OptionItem[] | undefined> {
    validFunc: ValidateFunc<T>;
}

// @public (undocumented)
export interface FxError extends Error {
    innerError?: any;
    source: string;
    timestamp: Date;
    // (undocumented)
    userData?: any;
}

// @public (undocumented)
class FxFailure<Error = FxError> {
    constructor(error: Error);
    // (undocumented)
    error: Error;
    // (undocumented)
    kind: "failure";
}

// @public (undocumented)
class FxPartialSuccess<T, Error = FxError> {
    constructor(output: T, error: Error);
    // (undocumented)
    error: Error;
    // (undocumented)
    kind: "partialSuccess";
    // (undocumented)
    output: T;
}

// @public (undocumented)
type FxResult<T, Error = FxError> = FxSuccess<T> | FxPartialSuccess<T, Error> | FxFailure<Error>;

// @public (undocumented)
class FxSuccess<T> {
    constructor(output: T);
    // (undocumented)
    kind: "success";
    // (undocumented)
    output: T;
}

// @public (undocumented)
export function getCallFuncValue(inputs: Inputs, raw?: unknown): Promise<unknown>;

// @public (undocumented)
export function getSingleOption(q: SingleSelectQuestion | MultiSelectQuestion, option?: StaticOptions): any;

// @public
export function getValidationFunction<T extends string | string[] | undefined>(validation: ValidationSchema, inputs: Inputs): (input: T) => string | undefined | Promise<string | undefined>;

// @public
export interface Group {
    // (undocumented)
    name?: string;
    // (undocumented)
    type: "group";
}

// @public
export interface GroupAction extends ActionBase {
    // (undocumented)
    actions: Action[];
    mode?: "sequential" | "parallel";
    // (undocumented)
    type: "group";
}

// @public
export class GroupOfTasks<T> implements RunnableTask<Result<T, FxError>[]> {
    constructor(tasks: RunnableTask<T>[], config?: TaskGroupConfig);
    // (undocumented)
    cancel(): void;
    // (undocumented)
    config?: TaskGroupConfig;
    // (undocumented)
    current: number;
    // (undocumented)
    isCanceled: boolean;
    // (undocumented)
    message?: string;
    // (undocumented)
    name?: string;
    // (undocumented)
    run(...args: any): Promise<Result<Result<T, FxError>[], FxError>>;
    // (undocumented)
    tasks: RunnableTask<T>[];
    // (undocumented)
    readonly total: number;
}

// @public (undocumented)
interface ICore extends Core {
    addFeature: (inputs: InputsWithProjectPath) => Promise<Result<Void, FxError>>;
    init: (inputs: InputsWithProjectPath & {
        solution?: string;
    }) => Promise<Result<Void, FxError>>;
}

// @public (undocumented)
export const InputConfigsFolderName = "configs";

// @public
export interface InputResult<T> {
    result?: T;
    type: "success" | "skip" | "back";
}

// @public (undocumented)
export interface Inputs extends Json {
    // (undocumented)
    env?: string;
    // (undocumented)
    existingResources?: string[];
    // (undocumented)
    ignoreConfigPersist?: boolean;
    // (undocumented)
    ignoreEnvInfo?: boolean;
    // (undocumented)
    isM365?: boolean;
    // (undocumented)
    locale?: string;
    // (undocumented)
    platform: Platform;
    // (undocumented)
    projectId?: string;
    // (undocumented)
    projectPath?: string;
    // (undocumented)
    sourceEnvName?: string;
    // (undocumented)
    stage?: Stage;
    // (undocumented)
    targetEnvName?: string;
    // (undocumented)
    targetResourceGroupName?: string;
    // (undocumented)
    targetResourceLocationName?: string;
    // (undocumented)
    targetSubscriptionId?: string;
    // (undocumented)
    vscodeEnv?: VsCodeEnv;
}

// @public (undocumented)
export type InputsWithProjectPath = Inputs & {
    projectPath: string;
};

// @public
export interface InputTextConfig extends UIConfig<string> {
    password?: boolean;
}

// @public (undocumented)
export type InputTextResult = InputResult<string>;

// @public (undocumented)
export class InvalidInputError extends UserError {
    constructor(source: string, name: string, reason?: string);
}

// @public (undocumented)
export class InvalidObjectError extends UserError {
    constructor(source: string, name: string, reason?: string);
}

// @public (undocumented)
export class InvalidOperationError extends UserError {
    constructor(source: string, name: string, reason?: string);
}

// @public (undocumented)
export class InvalidProjectError extends UserError {
    constructor(source: string, msg?: string);
}

// @public (undocumented)
export interface IProgressHandler {
    end: (success: boolean) => Promise<void>;
    next: (detail?: string) => Promise<void>;
    start: (detail?: string) => Promise<void>;
}

// @public (undocumented)
export function isAutoSkipSelect(q: Question): boolean;

// @public (undocumented)
interface ISolution {
    addFeature?: (ctx: Context_2, inputs: SolutionAddFeatureInputs) => Promise<Result<Void, FxError>>;
    // (undocumented)
    deploy?: (ctx: Context_2, inputs: InputsWithProjectPath, envInfo: DeepReadonly<EnvInfoV3>, tokenProvider: TokenProvider) => Promise<Result<Void, FxError>>;
    // (undocumented)
    executeUserTask?: (ctx: Context_2, inputs: Inputs, func: Func, envInfo: EnvInfoV3, tokenProvider: TokenProvider) => Promise<Result<any, FxError>>;
    getQuestionsForAddFeature?: (ctx: Context_2, inputs: InputsWithProjectPath) => Promise<Result<QTreeNode | undefined, FxError>>;
    // (undocumented)
    getQuestionsForDeploy?: (ctx: Context_2, inputs: InputsWithProjectPath, envInfo: DeepReadonly<EnvInfoV3>, tokenProvider: TokenProvider) => Promise<Result<QTreeNode | undefined, FxError>>;
    getQuestionsForInit?: (ctx: Context_2, inputs: Inputs) => Promise<Result<QTreeNode | undefined, FxError>>;
    // (undocumented)
    getQuestionsForProvision?: (ctx: Context_2, inputs: InputsWithProjectPath, envInfo: DeepReadonly<EnvInfoV3>, tokenProvider: TokenProvider) => Promise<Result<QTreeNode | undefined, FxError>>;
    // (undocumented)
    getQuestionsForPublish?: (ctx: Context_2, inputs: InputsWithProjectPath, envInfo: DeepReadonly<EnvInfoV3>, tokenProvider: M365TokenProvider) => Promise<Result<QTreeNode | undefined, FxError>>;
    // (undocumented)
    getQuestionsForUserTask?: (ctx: Context_2, inputs: Inputs, func: Func, envInfo: DeepReadonly<EnvInfoV3>, tokenProvider: TokenProvider) => Promise<Result<QTreeNode | undefined, FxError>>;
    // (undocumented)
    init?: (ctx: Context_2, inputs: InputsWithProjectPath) => Promise<Result<Void, FxError>>;
    // (undocumented)
    name: string;
    // (undocumented)
    provisionResources?: (ctx: Context_2, inputs: InputsWithProjectPath, envInfo: EnvInfoV3, tokenProvider: TokenProvider) => Promise<Result<Void, FxError>>;
    // (undocumented)
    publishApplication: (ctx: Context_2, inputs: InputsWithProjectPath, envInfo: DeepReadonly<EnvInfoV3>, tokenProvider: M365TokenProvider) => Promise<Result<Void, FxError>>;
}

// @public (undocumented)
export type Json = Record<string, any>;

// @public (undocumented)
type JsonTemplate = {
    kind: "json";
    template: Json;
};

// @public (undocumented)
export function loadOptions(q: Question, inputs: Inputs): Promise<Result<{
    autoSkip: boolean;
    options?: StaticOptions;
}, FxError>>;

// @public (undocumented)
export const LocalEnvironmentName = "local";

// @public
export type LocalFunc<T> = (inputs: Inputs) => T | Promise<T>;

// @public (undocumented)
type LocalSetting = {
    key: keyof LocalSettings_2;
    value: Record<string, string>;
};

// @public
export interface LocalSettings {
    // (undocumented)
    auth?: ConfigMap;
    // (undocumented)
    backend?: ConfigMap;
    // (undocumented)
    bot?: ConfigMap;
    // (undocumented)
    frontend?: ConfigMap;
    // (undocumented)
    teamsApp?: ConfigMap;
}

// @public (undocumented)
interface LocalSettings_2 extends Json {
    // (undocumented)
    auth?: Record<string, string>;
    // (undocumented)
    backend?: Record<string, string>;
    // (undocumented)
    bot?: Record<string, string>;
    // (undocumented)
    frontend?: Record<string, string>;
    // (undocumented)
    teamsApp: Record<string, string>;
}

// @public (undocumented)
export type LoginStatus = {
    status: string;
    token?: string;
    accountInfo?: Record<string, unknown>;
};

// @public (undocumented)
export enum LogLevel {
    Debug = 1,
    Error = 4,
    Fatal = 5,
    Info = 2,
    Trace = 0,
    Warning = 3
}

// @public (undocumented)
export interface LogProvider {
    debug(message: string): Promise<boolean>;
    error(message: string): Promise<boolean>;
    fatal(message: string): Promise<boolean>;
    info(message: string): Promise<boolean>;
    info(message: Array<{
        content: string;
        color: Colors;
    }>): Promise<boolean>;
    log(logLevel: LogLevel, message: string): Promise<boolean>;
    trace(message: string): Promise<boolean>;
    warning(message: string): Promise<boolean>;
}

// @public
export interface M365TokenProvider {
    getAccessToken(tokenRequest: TokenRequest): Promise<Result<string, FxError>>;
    getJsonObject(tokenRequest: TokenRequest): Promise<Result<Record<string, unknown>, FxError>>;
    getStatus(tokenRequest: TokenRequest): Promise<Result<LoginStatus, FxError>>;
    removeStatusChangeMap(name: string): Promise<Result<boolean, FxError>>;
    setStatusChangeMap(name: string, tokenRequest: TokenRequest, statusChange: (status: string, token?: string, accountInfo?: Record<string, unknown>) => Promise<void>, immediateCall?: boolean): Promise<Result<boolean, FxError>>;
}

// @public (undocumented)
type ManifestCapability = {
    name: "staticTab";
    snippet?: IStaticTab;
    existingApp?: boolean;
} | {
    name: "configurableTab";
    snippet?: IConfigurableTab;
    existingApp?: boolean;
} | {
    name: "Bot";
    snippet?: IBot;
    existingApp?: boolean;
} | {
    name: "MessageExtension";
    snippet?: IComposeExtension;
    existingApp?: boolean;
} | {
    name: "WebApplicationInfo";
    snippet?: IWebApplicationInfo;
    existingApp?: boolean;
};

// @public (undocumented)
export type MaybePromise<T> = T | Promise<T>;

// @public (undocumented)
export function mergeConfigMap(lhs?: ConfigMap, rhs?: ConfigMap): ConfigMap | undefined;

// @public (undocumented)
export interface MultiFileQuestion extends UserInputQuestion {
    default?: string | LocalFunc<string | undefined>;
    // (undocumented)
    type: "multiFile";
    validation?: FuncValidation<string[]>;
    value?: string[];
}

// @public
export interface MultiSelectConfig extends UIConfig<string[]> {
    onDidChangeSelection?: OnSelectionChangeFunc;
    options: StaticOptions;
    returnObject?: boolean;
}

// @public
export interface MultiSelectQuestion extends UserInputQuestion {
    default?: string[] | LocalFunc<string[] | undefined>;
    dynamicOptions?: DynamicOptions;
    onDidChangeSelection?: OnSelectionChangeFunc;
    returnObject?: boolean;
    skipSingleOption?: boolean;
    staticOptions: StaticOptions;
    // (undocumented)
    type: "multiSelect";
    validation?: StringArrayValidation | FuncValidation<string[]>;
    value?: string[] | OptionItem[];
}

// @public (undocumented)
export type MultiSelectResult = InputResult<StaticOptions>;

// @public (undocumented)
export class NoProjectOpenedError extends UserError {
    constructor(source: string);
}

// @public (undocumented)
export class NotImplementedError extends SystemError {
    constructor(source: string, method: string);
}

// @public (undocumented)
export class ObjectAlreadyExistsError extends UserError {
    constructor(source: string, name: string);
}

// @public (undocumented)
export class ObjectNotExistError extends UserError {
    constructor(source: string, name: string);
}

// @public (undocumented)
export type OnSelectionChangeFunc = (currentSelectedIds: Set<string>, previousSelectedIds: Set<string>) => Promise<Set<string>>;

// @public
export interface OptionItem {
    buttons?: {
        iconPath: string;
        tooltip: string;
        command: string;
    }[];
    cliName?: string;
    data?: unknown;
    description?: string;
    detail?: string;
    groupName?: string;
    id: string;
    label: string;
}

// @public (undocumented)
export class PathAlreadyExistsError extends UserError {
    constructor(source: string, path: string);
}

// @public (undocumented)
export class PathNotExistError extends UserError {
    constructor(source: string, path: string);
}

// @public
export interface PermissionRequestProvider {
    checkPermissionRequest(): Promise<Result<undefined, FxError>>;
    getPermissionRequest(): Promise<Result<string, FxError>>;
}

// @public
export enum Platform {
    // (undocumented)
    CLI = "cli",
    // (undocumented)
    CLI_HELP = "cli_help",
    // (undocumented)
    VS = "vs",
    // (undocumented)
    VSCode = "vsc"
}

// @public
interface Plugin_2 {
    activate(solutionSettings: AzureSolutionSettings): boolean;
    callFunc?: (func: Func, ctx: PluginContext) => Promise<Result<any, FxError>>;
    // (undocumented)
    checkPermission?: (ctx: PluginContext, userInfo: Record<string, any>) => Promise<Result<any, FxError>>;
    // (undocumented)
    deploy?: (ctx: PluginContext) => Promise<Result<any, FxError>>;
    // (undocumented)
    displayName: string;
    executeUserTask?: (func: Func, ctx: PluginContext) => Promise<Result<any, FxError>>;
    // (undocumented)
    generateArmTemplates?: (ctx: PluginContext) => Promise<Result<any, FxError>>;
    getQuestions?: (stage: Stage, ctx: PluginContext) => Promise<Result<QTreeNode | undefined, FxError>>;
    getQuestionsForUserTask?: (func: Func, ctx: PluginContext) => Promise<Result<QTreeNode | undefined, FxError>>;
    grantPermission?: (ctx: PluginContext, userInfo: Record<string, any>) => Promise<Result<any, FxError>>;
    // (undocumented)
    listCollaborator?: (ctx: PluginContext, userInfo: Record<string, any>) => Promise<Result<any, FxError>>;
    localDebug?: (ctx: PluginContext) => Promise<Result<any, FxError>>;
    // (undocumented)
    name: string;
    // (undocumented)
    postDeploy?: (ctx: PluginContext) => Promise<Result<any, FxError>>;
    // (undocumented)
    postLocalDebug?: (ctx: PluginContext) => Promise<Result<any, FxError>>;
    // (undocumented)
    postProvision?: (ctx: PluginContext) => Promise<Result<any, FxError>>;
    // (undocumented)
    postScaffold?: (ctx: PluginContext) => Promise<Result<any, FxError>>;
    // (undocumented)
    preDeploy?: (ctx: PluginContext) => Promise<Result<any, FxError>>;
    // (undocumented)
    preProvision?: (ctx: PluginContext) => Promise<Result<any, FxError>>;
    prerequisiteCheck?: (ctx: Readonly<Context>) => Promise<Result<{
        pass: true;
    } | {
        pass: false;
        msg: string;
    }, FxError>>;
    // (undocumented)
    preScaffold?: (ctx: PluginContext) => Promise<Result<any, FxError>>;
    // (undocumented)
    provision?: (ctx: PluginContext) => Promise<Result<any, FxError>>;
    publish?: (ctx: PluginContext) => Promise<Result<any, FxError>>;
    // (undocumented)
    scaffold?: (ctx: PluginContext) => Promise<Result<any, FxError>>;
    // (undocumented)
    updateArmTemplates?: (ctx: PluginContext) => Promise<Result<any, FxError>>;
}
export { Plugin_2 as Plugin }

// @public (undocumented)
export type PluginConfig = ConfigMap;

// @public (undocumented)
export interface PluginContext extends Context {
    // (undocumented)
    config: PluginConfig;
    // (undocumented)
    envInfo: EnvInfo;
}

// @public (undocumented)
export type PluginIdentity = string;

// @public (undocumented)
type PluginName = string;

// @public (undocumented)
type PluginV3 = AzureResourcePlugin;

// @public (undocumented)
export const ProductName = "teamsfx";

// @public (undocumented)
export interface ProjectConfig {
    // (undocumented)
    config?: SolutionConfig | Json;
    // (undocumented)
    localSettings?: LocalSettings | Json;
    // (undocumented)
    settings?: ProjectSettings;
}

// @public (undocumented)
export interface ProjectConfigV3 {
    // (undocumented)
    envInfos: {
        [key: string]: EnvInfoV3;
    };
    // (undocumented)
    projectSettings: ProjectSettings;
}

// @public
export interface ProjectSettings {
    // (undocumented)
    appName: string;
    // (undocumented)
    defaultFunctionName?: string;
    // (undocumented)
    isFromSample?: boolean;
    // (undocumented)
    isM365?: boolean;
    pluginSettings?: Json;
    // (undocumented)
    programmingLanguage?: string;
    // (undocumented)
    projectId: string;
    // (undocumented)
    solutionSettings?: SolutionSettings;
    // (undocumented)
    version?: string;
}

// @public (undocumented)
export const ProjectSettingsFileName = "projectSettings.json";

// @public (undocumented)
export interface ProjectSettingsV3 extends ProjectSettings {
    // (undocumented)
    components: Component[];
}

// @public
export interface ProjectStates {
    // (undocumented)
    resources: {
        [k: string]: Record<string, ConfigValue>;
    };
    // (undocumented)
    solution: Record<string, ConfigValue>;
}

// @public (undocumented)
export interface ProvisionBicep {
    // (undocumented)
    Modules?: {
        [moduleFileName: string]: string;
    };
    // (undocumented)
    Orchestration?: string;
}

// @public (undocumented)
type ProvisionInputs = InputsWithProjectPath & SolutionInputs;

// @public
export class QTreeNode {
    constructor(data: Question | Group);
    // (undocumented)
    addChild(node: QTreeNode): QTreeNode;
    // (undocumented)
    children?: QTreeNode[];
    // (undocumented)
    condition?: ValidationSchema & {
        target?: string;
    };
    // (undocumented)
    data: Question | Group;
    trim(): QTreeNode | undefined;
    // (undocumented)
    validate(): boolean;
}

// @public (undocumented)
export type Question = SingleSelectQuestion | MultiSelectQuestion | TextInputQuestion | SingleFileQuestion | MultiFileQuestion | FolderQuestion | FuncQuestion | SingleFileQuestion;

// @public (undocumented)
export class ReadFileError extends SystemError {
    constructor(source: string, e: Error);
}

// @public (undocumented)
export type ReadonlyPluginConfig = ReadonlyMap<string, ConfigValue>;

// @public (undocumented)
export type ReadonlyResourceConfig = Readonly<ResourceConfig>;

// @public (undocumented)
export type ReadonlyResourceConfigs = Readonly<{
    [k: string]: ReadonlyResourceConfig | undefined;
}>;

// @public (undocumented)
export type ReadonlySolutionConfig = ReadonlyMap<PluginIdentity, ReadonlyPluginConfig>;

// @public (undocumented)
export type ResourceConfig = ResourceTemplate;

// @public (undocumented)
export type ResourceConfigs = ResourceTemplates;

// @public (undocumented)
export interface ResourceContextV3 extends ContextV3 {
    // (undocumented)
    envInfo: EnvInfoV3;
    // (undocumented)
    tokenProvider: TokenProvider;
}

// @public (undocumented)
export interface ResourceOutput {
    // (undocumented)
    bicepVariable?: string;
    // (undocumented)
    key: string;
}

// @public (undocumented)
export interface ResourceOutputs {
    // (undocumented)
    [k: string]: ResourceOutput;
}

// @public
interface ResourcePlugin {
    activate(projectSettings: ProjectSettings): boolean;
    // (undocumented)
    checkPermission?: (ctx: Context_2, inputs: InputsWithProjectPath, envInfo: DeepReadonly<EnvInfoV2>, tokenProvider: TokenProvider, userInfo: Json) => Promise<Result<Json, FxError>>;
    configureLocalResource?: (ctx: Context_2, inputs: Inputs, localSettings: Json, tokenProvider: TokenProvider, envInfo?: EnvInfoV2) => Promise<Result<Void, FxError>>;
    configureResource?: (ctx: Context_2, inputs: ProvisionInputs, envInfo: EnvInfoV2, tokenProvider: TokenProvider) => Promise<Result<Void, FxError>>;
    deploy?: (ctx: Context_2, inputs: DeploymentInputs, envInfo: DeepReadonly<EnvInfoV2>, tokenProvider: TokenProvider) => Promise<Result<Void, FxError>>;
    // (undocumented)
    displayName: string;
    // (undocumented)
    executeUserTask?: (ctx: Context_2, inputs: Inputs, func: Func, localSettings: Json, envInfo: EnvInfoV2, tokenProvider: TokenProvider) => Promise<Result<unknown, FxError>>;
    generateResourceTemplate?: (ctx: Context_2, inputs: Inputs & {
        existingResources: string[];
    }) => Promise<Result<ResourceTemplate_2, FxError>>;
    // (undocumented)
    getQuestions?: (ctx: Context_2, inputs: Inputs, envInfo: DeepReadonly<EnvInfoV2>, tokenProvider: TokenProvider) => Promise<Result<QTreeNode | undefined, FxError>>;
    getQuestionsForScaffolding?: (ctx: Context_2, inputs: Inputs) => Promise<Result<QTreeNode | undefined, FxError>>;
    // (undocumented)
    getQuestionsForUserTask?: (ctx: Context_2, inputs: Inputs, func: Func, envInfo: DeepReadonly<EnvInfoV2>, tokenProvider: TokenProvider) => Promise<Result<QTreeNode | undefined, FxError>>;
    grantPermission?: (ctx: Context_2, inputs: InputsWithProjectPath, envInfo: DeepReadonly<EnvInfoV2>, tokenProvider: TokenProvider, userInfo: Json) => Promise<Result<Json, FxError>>;
    // (undocumented)
    listCollaborator?: (ctx: Context_2, inputs: InputsWithProjectPath, envInfo: DeepReadonly<EnvInfoV2>, tokenProvider: TokenProvider, userInfo: Json) => Promise<Result<Json, FxError>>;
    // (undocumented)
    name: string;
    provisionLocalResource?: (ctx: Context_2, inputs: Inputs, localSettings: Json, tokenProvider: TokenProvider, envInfo?: EnvInfoV2) => Promise<Result<Void, FxError>>;
    provisionResource?: (ctx: Context_2, inputs: ProvisionInputs, envInfo: EnvInfoV2, tokenProvider: TokenProvider) => Promise<Result<Void, FxError>>;
    publishApplication?: (ctx: Context_2, inputs: Inputs, envInfo: DeepReadonly<EnvInfoV2>, tokenProvider: M365TokenProvider) => Promise<Result<Void, FxError>>;
    scaffoldSourceCode?: (ctx: Context_2, inputs: Inputs) => Promise<Result<Void, FxError>>;
    // (undocumented)
    updateResourceTemplate?: (ctx: Context_2, inputs: Inputs & {
        existingResources: string[];
    }) => Promise<Result<ResourceTemplate_2, FxError>>;
}

// @public (undocumented)
type ResourceProvisionOutput = {
    output: Json;
    secrets: Json;
};

// @public
interface ResourceStates {
    [key: string]: CloudResource_2;
    solution: Json;
}

// @public (undocumented)
export type ResourceTemplate = Record<string, ConfigValue>;

// @public (undocumented)
type ResourceTemplate_2 = BicepTemplate | JsonTemplate;

// @public (undocumented)
export type ResourceTemplates = {
    [k: string]: ResourceTemplate | undefined;
};

// @public
export interface RunnableTask<T> {
    cancel?(): void;
    current?: number;
    isCanceled?: boolean;
    message?: string;
    name?: string;
    run(...args: any): Promise<Result<T, FxError>>;
    readonly total?: number;
}

// @public
export type SelectFileConfig = UIConfig<string>;

// @public (undocumented)
export type SelectFileResult = InputResult<string>;

// @public
export type SelectFilesConfig = UIConfig<string[]>;

// @public (undocumented)
export type SelectFilesResult = InputResult<string[]>;

// @public
export type SelectFolderConfig = UIConfig<string>;

// @public (undocumented)
export type SelectFolderResult = InputResult<string>;

// @public
export interface ShellAction extends ActionBase {
    // (undocumented)
    async?: boolean;
    // (undocumented)
    captureStderr?: boolean;
    // (undocumented)
    captureStdout?: boolean;
    // (undocumented)
    command: string;
    // (undocumented)
    cwd?: string;
    // (undocumented)
    description: string;
    // (undocumented)
    type: "shell";
}

// @public (undocumented)
interface SimpleAuth extends AzureResource {
    // (undocumented)
    endpoint: string;
    // (undocumented)
    webAppResourceId: string;
}

// @public
export interface SingleFileQuestion extends UserInputQuestion {
    default?: string | LocalFunc<string | undefined>;
    // (undocumented)
    type: "singleFile";
    validation?: FuncValidation<string>;
    value?: string;
}

// @public
export interface SingleSelectConfig extends UIConfig<string> {
    options: StaticOptions;
    returnObject?: boolean;
}

// @public
export interface SingleSelectQuestion extends UserInputQuestion {
    default?: string | LocalFunc<string | undefined>;
    dynamicOptions?: DynamicOptions;
    returnObject?: boolean;
    skipSingleOption?: boolean;
    staticOptions: StaticOptions;
    // (undocumented)
    type: "singleSelect";
    value?: string | OptionItem;
}

// @public (undocumented)
export type SingleSelectResult = InputResult<string | OptionItem>;

// @public (undocumented)
export interface Solution {
    // (undocumented)
    activateEnv?: (ctx: SolutionContext) => Promise<Result<any, FxError>>;
    // (undocumented)
    checkPermission?: (ctx: SolutionContext) => Promise<Result<any, FxError>>;
    // (undocumented)
    create: (ctx: SolutionContext) => Promise<Result<any, FxError>>;
    createEnv?: (ctx: SolutionContext) => Promise<Result<any, FxError>>;
    // (undocumented)
    deploy: (ctx: SolutionContext) => Promise<Result<any, FxError>>;
    // (undocumented)
    executeUserTask?: (func: Func, ctx: SolutionContext) => Promise<Result<any, FxError>>;
    // (undocumented)
    getQuestions: (task: Stage, ctx: SolutionContext) => Promise<Result<QTreeNode | undefined, FxError>>;
    // (undocumented)
    getQuestionsForUserTask?: (func: Func, ctx: SolutionContext) => Promise<Result<QTreeNode | undefined, FxError>>;
    grantPermission?: (ctx: SolutionContext) => Promise<Result<any, FxError>>;
    // (undocumented)
    listCollaborator?: (ctx: SolutionContext) => Promise<Result<any, FxError>>;
    // (undocumented)
    localDebug: (ctx: SolutionContext) => Promise<Result<any, FxError>>;
    // (undocumented)
    name: string;
    // (undocumented)
    provision: (ctx: SolutionContext) => Promise<Result<any, FxError>>;
    // (undocumented)
    publish: (ctx: SolutionContext) => Promise<Result<any, FxError>>;
    // (undocumented)
    scaffold: (ctx: SolutionContext) => Promise<Result<any, FxError>>;
}

// @public (undocumented)
interface SolutionAddFeatureInputs extends InputsWithProjectPath {
    // (undocumented)
    features: string[];
}

// @public (undocumented)
export type SolutionConfig = Map<PluginIdentity, PluginConfig>;

// @public (undocumented)
export interface SolutionContext extends Context {
    // (undocumented)
    envInfo: EnvInfo;
}

// @public (undocumented)
type SolutionInputs = {
    resourceNameSuffix: string;
    resourceGroupName: string;
    location: string;
    teamsAppTenantId: string;
    subscriptionId: string;
    tenantId: string;
    remoteTeamsAppId?: string;
    provisionSucceeded?: boolean;
};

// @public (undocumented)
interface SolutionPlugin {
    // (undocumented)
    activateEnv?: (ctx: Context_2, inputs: Inputs) => Promise<Result<Void, FxError>>;
    // (undocumented)
    checkPermission?: (ctx: Context_2, inputs: InputsWithProjectPath, envInfo: DeepReadonly<EnvInfoV2>, tokenProvider: TokenProvider) => Promise<Result<Json, FxError>>;
    createEnv?: (ctx: Context_2, inputs: Inputs) => Promise<Result<Void, FxError>>;
    deploy?: (ctx: Context_2, inputs: Inputs, envInfo: DeepReadonly<EnvInfoV2>, tokenProvider: TokenProvider) => Promise<Result<Void, FxError>>;
    // (undocumented)
    displayName: string;
    executeUserTask?: (ctx: Context_2, inputs: Inputs, func: Func, localSettings: Json, envInfo: EnvInfoV2, tokenProvider: TokenProvider) => Promise<Result<unknown, FxError>>;
    generateResourceTemplate: (ctx: Context_2, inputs: Inputs) => Promise<Result<Json, FxError>>;
    // (undocumented)
    getQuestions?: (ctx: Context_2, inputs: Inputs, envInfo: DeepReadonly<EnvInfoV2>, tokenProvider: TokenProvider) => Promise<Result<QTreeNode | undefined, FxError>>;
    getQuestionsForScaffolding?: (ctx: Context_2, inputs: Inputs) => Promise<Result<QTreeNode | undefined, FxError>>;
    // (undocumented)
    getQuestionsForUserTask?: (ctx: Context_2, inputs: Inputs, func: Func, envInfo: DeepReadonly<EnvInfoV2>, tokenProvider: TokenProvider) => Promise<Result<QTreeNode | undefined, FxError>>;
    grantPermission?: (ctx: Context_2, inputs: InputsWithProjectPath, envInfo: DeepReadonly<EnvInfoV2>, tokenProvider: TokenProvider) => Promise<Result<Json, FxError>>;
    // (undocumented)
    listCollaborator?: (ctx: Context_2, inputs: InputsWithProjectPath, envInfo: DeepReadonly<EnvInfoV2>, tokenProvider: TokenProvider) => Promise<Result<Json, FxError>>;
    // (undocumented)
    name: string;
    provisionLocalResource?: (ctx: Context_2, inputs: Inputs, localSettings: Json, tokenProvider: TokenProvider, envInfo?: EnvInfoV2) => Promise<FxResult<Json, FxError>>;
    provisionResources: (ctx: Context_2, inputs: Inputs, envInfo: EnvInfoV2, tokenProvider: TokenProvider) => Promise<Result<Void, FxError>>;
    publishApplication: (ctx: Context_2, inputs: Inputs, envInfo: DeepReadonly<EnvInfoV2>, tokenProvider: M365TokenProvider) => Promise<Result<Void, FxError>>;
    scaffoldSourceCode: (ctx: Context_2, inputs: Inputs) => Promise<Result<Void, FxError>>;
}

// @public (undocumented)
type SolutionProvisionOutput = Record<string, ResourceProvisionOutput>;

// @public
export interface SolutionSettings extends Json {
    // (undocumented)
    name: string;
    version?: string;
}

// @public (undocumented)
export enum Stage {
    // (undocumented)
    activateEnv = "activateEnv",
    // (undocumented)
    addCapability = "addCapability",
    // (undocumented)
    addCiCdFlow = "addCiCdFlow",
    // (undocumented)
    addFeature = "addFeature",
    // (undocumented)
    addResource = "addResource",
    // (undocumented)
    build = "build",
    // (undocumented)
    checkPermission = "checkPermission",
    // (undocumented)
    create = "create",
    // (undocumented)
    createEnv = "createEnv",
    // (undocumented)
    debug = "debug",
    // (undocumented)
    deploy = "deploy",
    // (undocumented)
    getProjectConfig = "getProjectConfig",
    // (undocumented)
    getQuestions = "getQuestions",
    // (undocumented)
    grantPermission = "grantPermission",
    // (undocumented)
    init = "init",
    // (undocumented)
    listCollaborator = "listCollaborator",
    // (undocumented)
    listEnv = "listEnv",
    // (undocumented)
    package = "package",
    // (undocumented)
    provision = "provision",
    // (undocumented)
    publish = "publish",
    // (undocumented)
    removeEnv = "removeEnv",
    // (undocumented)
    switchEnv = "switchEnv",
    // (undocumented)
    update = "update",
    // (undocumented)
    userTask = "userTask"
}

// @public (undocumented)
export const StatesFolderName = "states";

// @public
export type StaticOptions = string[] | OptionItem[];

// @public (undocumented)
export const StaticPlatforms: Platform[];

// @public
export interface StaticValidation {
    equals?: unknown;
    required?: boolean;
}

// @public
export interface StringArrayValidation extends StaticValidation {
    contains?: string;
    containsAll?: string[];
    containsAny?: string[];
    enum?: string[];
    equals?: string[];
    excludes?: string;
    maxItems?: number;
    minItems?: number;
    uniqueItems?: boolean;
}

// @public
export interface StringValidation extends StaticValidation {
    endsWith?: string;
    enum?: string[];
    equals?: string;
    includes?: string;
    maxLength?: number;
    minLength?: number;
    notEquals?: string;
    pattern?: string;
    startsWith?: string;
}

// @public (undocumented)
export type SubscriptionInfo = {
    subscriptionName: string;
    subscriptionId: string;
    tenantId: string;
};

// @public
export class SystemError extends Error implements FxError {
    constructor(opt: SystemErrorOptions);
    constructor(source: string, name: string, message: string, displayMessage?: string);
    displayMessage?: string;
    innerError?: any;
    issueLink?: string;
    source: string;
    timestamp: Date;
    userData?: string;
}

// @public (undocumented)
export interface SystemErrorOptions extends ErrorOptionBase {
    // (undocumented)
    issueLink?: string;
}

// @public
export interface TaskConfig {
    cancellable?: boolean;
    showProgress?: boolean;
}

// @public
export interface TaskGroupConfig {
    fastFail?: boolean;
    sequential?: boolean;
}

// @public (undocumented)
interface TeamsAppResource extends AzureResource {
    teamsAppId: string;
    tenantId: string;
}

// @public (undocumented)
interface TeamsFxAzureResourceStates extends ResourceStates {
    // (undocumented)
    [key: string]: AzureResource;
    solution: AzureSolutionConfig;
}

// @public (undocumented)
export enum TelemetryEvent {
    // (undocumented)
    askQuestion = "askQuestion"
}

// @public (undocumented)
export enum TelemetryProperty {
    // (undocumented)
    answer = "answer",
    // (undocumented)
    answerType = "answerType",
    // (undocumented)
    platform = "platform",
    // (undocumented)
    question = "question",
    // (undocumented)
    stage = "stage"
}

// @public
export interface TelemetryReporter {
    sendTelemetryErrorEvent(eventName: string, properties?: {
        [key: string]: string;
    }, measurements?: {
        [key: string]: number;
    }, errorProps?: string[]): void;
    sendTelemetryEvent(eventName: string, properties?: {
        [key: string]: string;
    }, measurements?: {
        [key: string]: number;
    }): void;
    sendTelemetryException(error: Error, properties?: {
        [key: string]: string;
    }, measurements?: {
        [key: string]: number;
    }): void;
}

// @public (undocumented)
export const TemplateFolderName = "templates";

// @public
export interface TextInputQuestion extends UserInputQuestion {
    default?: string | LocalFunc<string | undefined>;
    password?: boolean;
    // (undocumented)
    type: "text";
    validation?: StringValidation | FuncValidation<string>;
    value?: string;
}

// @public (undocumented)
export type TokenProvider = {
    azureAccountProvider: AzureAccountProvider;
    m365TokenProvider: M365TokenProvider;
};

// @public (undocumented)
export type TokenRequest = {
    scopes: Array<string>;
    showDialog?: boolean;
};

// @public (undocumented)
export interface Tools {
    // (undocumented)
    cryptoProvider?: CryptoProvider;
    // (undocumented)
    expServiceProvider?: ExpServiceProvider;
    // (undocumented)
    logProvider: LogProvider;
    // (undocumented)
    permissionRequest?: PermissionRequestProvider;
    // (undocumented)
    telemetryReporter?: TelemetryReporter;
    // (undocumented)
    tokenProvider: TokenProvider;
    // (undocumented)
    treeProvider?: TreeProvider;
    // (undocumented)
    ui: UserInteraction;
}

// @public (undocumented)
export function traverse(root: QTreeNode, inputs: Inputs, ui: UserInteraction, telemetryReporter?: TelemetryReporter, visitor?: (question: Question, ui: UserInteraction, inputs: Inputs, step?: number | undefined, totalSteps?: number | undefined) => Promise<Result<InputResult<any>, FxError>>): Promise<Result<Void, FxError>>;

// @public (undocumented)
export enum TreeCategory {
    // (undocumented)
    Account = 1,
    // (undocumented)
    Environment = 5,
    // (undocumented)
    Feedback = 2,
    // (undocumented)
    GettingStarted = 0,
    // (undocumented)
    Project = 3,
    // (undocumented)
    Provision = 4
}

// @public (undocumented)
export interface TreeItem {
    // (undocumented)
    callback?: (args: any) => Promise<Result<null, FxError>>;
    // (undocumented)
    commandId: string;
    // (undocumented)
    contextValue?: string;
    // (undocumented)
    description?: string;
    // (undocumented)
    expanded?: boolean;
    // (undocumented)
    icon?: string;
    // (undocumented)
    isCustom?: boolean;
    // (undocumented)
    label: string;
    // (undocumented)
    parent?: TreeCategory | string;
    // (undocumented)
    subTreeItems?: TreeItem[];
    // (undocumented)
    tooltip?: {
        value: string;
        isMarkdown: boolean;
    };
}

// @public (undocumented)
export interface TreeProvider {
    // (undocumented)
    add: (tree: TreeItem[]) => Promise<Result<null, FxError>>;
    // (undocumented)
    refresh: (tree: TreeItem[]) => Promise<Result<null, FxError>>;
    // (undocumented)
    remove: (tree: TreeItem[]) => Promise<Result<null, FxError>>;
}

// @public
export interface UIConfig<T> {
    buttons?: {
        icon: string;
        tooltip: string;
        command: string;
    }[];
    default?: T;
    name: string;
    placeholder?: string;
    prompt?: string;
    step?: number;
    title: string;
    totalSteps?: number;
    validation?: (input: T) => string | undefined | Promise<string | undefined>;
}

// @public (undocumented)
export class UndefinedError extends SystemError {
    constructor(source: string, name: string);
}

// @public (undocumented)
export class UnknownError extends SystemError {
    constructor(source?: string, message?: string);
}

// @public (undocumented)
interface UpdateInputs extends AddFeatureInputs {
    newPlugins: string[];
}

// @public (undocumented)
export const UserCancelError: UserError;

// @public
export class UserError extends Error implements FxError {
    constructor(opt: UserErrorOptions);
    constructor(source: string, name: string, message: string, displayMessage?: string);
    displayMessage?: string;
    helpLink?: string;
    innerError?: any;
    source: string;
    timestamp: Date;
    userData?: string;
}

// @public (undocumented)
export interface UserErrorOptions extends ErrorOptionBase {
    // (undocumented)
    helpLink?: string;
}

// @public
export interface UserInputQuestion extends BaseQuestion {
    default?: string | string[] | LocalFunc<string | string[] | undefined>;
    placeholder?: string | LocalFunc<string | undefined>;
    prompt?: string | LocalFunc<string | undefined>;
    title: string;
    type: "singleSelect" | "multiSelect" | "singleFile" | "multiFile" | "folder" | "text";
    validation?: ValidationSchema;
    validationHelp?: string;
}

// @public
export interface UserInteraction {
    createProgressBar: (title: string, totalSteps: number) => IProgressHandler;
    executeFunction?(config: ExecuteFuncConfig): any | Promise<any>;
    inputText: (config: InputTextConfig) => Promise<Result<InputTextResult, FxError>>;
    openUrl(link: string): Promise<Result<boolean, FxError>>;
    reload?(): Promise<Result<boolean, FxError>>;
    runWithProgress<T>(task: RunnableTask<T>, config: TaskConfig, ...args: any): Promise<Result<T, FxError>>;
    selectFile: (config: SelectFileConfig) => Promise<Result<SelectFileResult, FxError>>;
    selectFiles: (config: SelectFilesConfig) => Promise<Result<SelectFilesResult, FxError>>;
    selectFolder: (config: SelectFolderConfig) => Promise<Result<SelectFolderResult, FxError>>;
    selectOption: (config: SingleSelectConfig) => Promise<Result<SingleSelectResult, FxError>>;
    selectOptions: (config: MultiSelectConfig) => Promise<Result<MultiSelectResult, FxError>>;
    showMessage(level: "info" | "warn" | "error", message: string, modal: boolean, ...items: string[]): Promise<Result<string | undefined, FxError>>;
    showMessage(level: "info" | "warn" | "error", message: Array<{
        content: string;
        color: Colors;
    }>, modal: boolean, ...items: string[]): Promise<Result<string | undefined, FxError>>;
}

declare namespace v2 {
    export {
        ResourceTemplate_2 as ResourceTemplate,
        JsonTemplate,
        BicepTemplate,
        ResourceProvisionOutput,
        ResourcePlugin,
        SolutionProvisionOutput,
        SolutionPlugin,
        PluginName,
        Context_2 as Context,
        LocalSettings_2 as LocalSettings,
        LocalSetting,
        SolutionInputs,
        InputsWithProjectPath,
        ProvisionInputs,
        DeploymentInputs,
        FxSuccess,
        FxPartialSuccess,
        FxFailure,
        FxResult,
        EnvInfoV2,
        DeepReadonly
    }
}
export { v2 }

declare namespace v3 {
    export {
        EnvInfoV3,
        ManifestCapability,
        CloudResource_2 as CloudResource,
        ResourceStates,
        AzureResource,
        AzureSolutionConfig,
        TeamsAppResource,
        TeamsFxAzureResourceStates,
        AppManifestProvider,
        ContextWithManifestProvider,
        AddFeatureInputs,
        BicepTemplate_2 as BicepTemplate,
        UpdateInputs,
        AzureResourcePlugin,
        PluginV3,
        SolutionAddFeatureInputs,
        ISolution,
        ICore,
        AzureIdentity,
        FrontendHostingResource,
        AzureSQL,
        AzureBot,
        AADApp,
        AzureFunction,
        APIM,
        SimpleAuth
    }
}
export { v3 }

// @public
export function validate<T extends string | string[] | OptionItem | OptionItem[] | undefined>(validSchema: ValidationSchema, value: T, inputs?: Inputs): Promise<string | undefined>;

// @public (undocumented)
export type ValidateFunc<T> = (input: T, inputs?: Inputs) => string | undefined | Promise<string | undefined>;

// @public
export type ValidationSchema = StringValidation | StringArrayValidation | FuncValidation<any>;

// @public (undocumented)
export type Void = {};

// @public (undocumented)
export const Void: {};

// @public (undocumented)
export interface VsCode {
    addConfigurations: (configurations: any) => Promise<Result<null, FxError>>;
    // (undocumented)
    addInputs: (iputs: any) => Promise<Result<null, FxError>>;
    addRecommendations: (recommendations: any) => Promise<Result<null, FxError>>;
    addSettings: (settings: any) => Promise<Result<null, FxError>>;
    addTasks: (tasks: any) => Promise<Result<null, FxError>>;
}

// @public (undocumented)
export enum VsCodeEnv {
    // (undocumented)
    codespaceBrowser = "codespaceBrowser",
    // (undocumented)
    codespaceVsCode = "codespaceVsCode",
    // (undocumented)
    local = "local",
    // (undocumented)
    remote = "remote"
}

// @public (undocumented)
export class WriteFileError extends SystemError {
    constructor(source: string, e: Error);
}


export * from "@microsoft/teams-manifest";
export * from "neverthrow";

// (No @packageDocumentation comment for this package)

```
