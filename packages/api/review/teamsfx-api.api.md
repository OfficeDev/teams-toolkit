## API Report File for "@microsoft/teamsfx-api"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { IBot } from '@microsoft/teams-manifest';
import { IComposeExtension } from '@microsoft/teams-manifest';
import { IConfigurableTab } from '@microsoft/teams-manifest';
import { IStaticTab } from '@microsoft/teams-manifest';
import { IWebApplicationInfo } from '@microsoft/teams-manifest';
import { Result } from 'neverthrow';
import { TokenCredential } from '@azure/core-auth';

// @public (undocumented)
export const AdaptiveFolderName = "adaptiveCards";

// @public (undocumented)
export interface ApiOperation {
    // (undocumented)
    groupName: string;
    // (undocumented)
    id: string;
    // (undocumented)
    label: string;
}

// @public (undocumented)
export const AppPackageFolderName = "appPackage";

// @public (undocumented)
export const AutoGeneratedReadme = "README-auto-generated.md";

// @public
export interface AzureAccountProvider {
    getAccountInfo(): Record<string, string> | undefined;
    getIdentityCredential?(credential: AzureCredential): Promise<TokenCredential | undefined>;
    getIdentityCredentialAsync(showDialog?: boolean): Promise<TokenCredential | undefined>;
    getJsonObject(showDialog?: boolean): Promise<Record<string, unknown> | undefined>;
    getSelectedSubscription(triggerUI?: boolean): Promise<SubscriptionInfo | undefined>;
    listSubscriptions(): Promise<SubscriptionInfo[]>;
    removeStatusChangeMap(name: string): Promise<boolean>;
    setStatusChangeMap(name: string, statusChange: (status: string, token?: string, accountInfo?: Record<string, unknown>) => Promise<void>, immediateCall?: boolean): Promise<boolean>;
    setSubscription(subscriptionId: string): Promise<void>;
    signout(): Promise<boolean>;
}

// @public (undocumented)
export type AzureCredential = {
    type: "AuthorizationCode";
    username: string;
    tenantId?: string;
    popUpSignIn?: boolean;
} | {
    type: "ClientSecretCredential";
    tenantId: string;
    clientId: string;
    clientSecret: string;
} | {
    type: "ClientCertificateCredential";
    tenantId: string;
    clientId: string;
    certificatePath: string;
};

// @public
export interface BaseQuestion {
    buttons?: {
        icon: string;
        tooltip: string;
        command: string;
    }[];
    default?: unknown;
    forgetLastValue?: boolean;
    name: string;
    step?: number;
    title?: string | LocalFunc<string | undefined>;
    totalSteps?: number;
    value?: unknown;
    // (undocumented)
    valueType?: "skip" | "success";
}

// @public
export abstract class BasicLogin {
    // (undocumented)
    abstract getStatus(tokenRequest: TokenRequest): Promise<Result<LoginStatus, FxError>>;
    // (undocumented)
    notifyStatus(tokenRequest: TokenRequest): Promise<void>;
    // (undocumented)
    removeStatusChangeMap(name: string): Promise<Result<boolean, FxError>>;
    // (undocumented)
    setStatusChangeMap(name: string, tokenRequest: TokenRequest, statusChange: (status: string, token?: string, accountInfo?: Record<string, unknown>) => Promise<void>, immediateCall?: boolean): Promise<Result<boolean, FxError>>;
    // (undocumented)
    statusChangeMap: Map<any, any>;
}

// @public (undocumented)
export const BuildFolderName = "build";

// Warning: (ae-forgotten-export) The symbol "CLICommandOptionBase" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export interface CLIArrayOption extends CLICommandOptionBase {
    choiceListCommand?: string;
    choices?: string[];
    default?: string[];
    skipValidation?: boolean;
    // (undocumented)
    type: "array";
    value?: string[];
}

// @public (undocumented)
export interface CLIBooleanOption extends CLICommandOptionBase {
    default?: boolean;
    // (undocumented)
    type: "boolean";
    value?: boolean;
}

// @public (undocumented)
export interface CLICommand {
    arguments?: CLICommandArgument[];
    commands?: CLICommand[];
    defaultInteractiveOption?: boolean;
    description: string;
    examples?: CLIExample[];
    footer?: string;
    fullName?: string;
    handler?: (ctx: CLIContext) => Promise<Result<undefined, FxError>> | Result<undefined, FxError>;
    header?: string;
    hidden?: boolean;
    name: string;
    options?: CLICommandOption[];
    reservedOptionNamesInInteractiveMode?: string[];
    sortCommands?: boolean;
    sortOptions?: boolean;
    telemetry?: {
        event: string;
    };
    version?: string;
}

// @public (undocumented)
export type CLICommandArgument = CLICommandOption;

// @public (undocumented)
export type CLICommandOption = CLIBooleanOption | CLIStringOption | CLIArrayOption;

// @public (undocumented)
export interface CLIContext {
    argumentValues: OptionValue[];
    command: CLIFoundCommand;
    globalOptionValues: Record<string, OptionValue>;
    optionValues: Record<string, OptionValue>;
    telemetryProperties: Record<string, string>;
}

// @public (undocumented)
export interface CLIExample {
    command: string;
    description: string;
}

// @public (undocumented)
export interface CLIFoundCommand extends CLICommand {
    // (undocumented)
    fullName: string;
}

// @public (undocumented)
export type CLIOptionType = "boolean" | "string" | "array";

// @public (undocumented)
export const CLIPlatforms: Platform[];

// @public (undocumented)
export interface CLIStringOption extends CLICommandOptionBase {
    choiceListCommand?: string;
    choices?: string[];
    default?: string;
    skipValidation?: boolean;
    // (undocumented)
    type: "string";
    value?: string;
}

// @public
export enum Colors {
    BRIGHT_CYAN = 6,
    BRIGHT_GREEN = 3,
    BRIGHT_MAGENTA = 2,
    BRIGHT_RED = 5,
    BRIGHT_WHITE = 0,
    BRIGHT_YELLOW = 4,
    WHITE = 1
}

// @public (undocumented)
export type ConditionFunc = (inputs: Inputs) => boolean | Promise<boolean>;

// @public (undocumented)
export const ConfigFolderName = "fx";

// @public (undocumented)
export interface Context {
    // (undocumented)
    expServiceProvider?: ExpServiceProvider;
    // (undocumented)
    logProvider: LogProvider;
    // (undocumented)
    projectPath?: string;
    // (undocumented)
    telemetryReporter: TelemetryReporter;
    // (undocumented)
    templateVariables?: {
        [key: string]: string;
    };
    // (undocumented)
    tokenProvider?: TokenProvider;
    // (undocumented)
    userInteraction: UserInteraction;
}

// @public
export enum CoreCallbackEvent {
    // (undocumented)
    lock = "lock",
    // (undocumented)
    unlock = "unlock"
}

// @public (undocumented)
export interface CreateProjectResult {
    // (undocumented)
    projectPath: string;
    // (undocumented)
    warnings?: Warning[];
}

// @public
export interface CryptoProvider {
    decrypt(ciphertext: string): Result<string, FxError>;
    encrypt(plaintext: string): Result<string, FxError>;
}

// @public (undocumented)
export type DeepReadonly<T> = {
    readonly [P in keyof T]: DeepReadonly<T[P]>;
};

// @public (undocumented)
export const DefaultReadme = "README.md";

// @public
export type DynamicOptions = LocalFunc<StaticOptions>;

// @public (undocumented)
export const DynamicPlatforms: Platform[];

// @public
export interface EnvMeta {
    // (undocumented)
    local: boolean;
    // (undocumented)
    name: string;
    // (undocumented)
    sideloading: boolean;
}

// @public (undocumented)
export interface ErrorOptionBase {
    // (undocumented)
    categories?: string[];
    // (undocumented)
    displayMessage?: string;
    // (undocumented)
    error?: Error;
    // (undocumented)
    message?: string;
    // (undocumented)
    name?: string;
    // (undocumented)
    source?: string;
    // (undocumented)
    userData?: any;
}

// @public
export interface ExecuteFuncConfig extends UIConfig<string> {
    // (undocumented)
    func: LocalFunc<any>;
    // (undocumented)
    inputs: Inputs;
}

// @public (undocumented)
export interface ExpServiceProvider {
    // (undocumented)
    getTreatmentVariableAsync<T extends boolean | number | string>(configId: string, name: string, checkCache?: boolean): Promise<T | undefined>;
}

// @public (undocumented)
export interface FolderQuestion extends UserInputQuestion {
    default?: string | LocalFunc<string | undefined>;
    // (undocumented)
    type: "folder";
    validation?: FuncValidation<string>;
    value?: string;
}

// @public (undocumented)
export interface Func extends FunctionRouter {
    // (undocumented)
    params?: any;
}

// @public (undocumented)
export interface FunctionRouter {
    // (undocumented)
    method: string;
    // (undocumented)
    namespace: string;
}

// @public
export interface FuncValidation<T extends string | string[] | OptionItem | OptionItem[] | undefined> {
    validFunc: ValidateFunc<T>;
}

// @public (undocumented)
export interface FxError extends Error {
    // (undocumented)
    categories?: string[];
    innerError?: any;
    source: string;
    timestamp: Date;
    // (undocumented)
    userData?: any;
}

// @public
export function getValidationFunction<T extends string | string[] | undefined>(validation: ValidationSchema, inputs: Inputs): (input: T) => string | undefined | Promise<string | undefined>;

// @public
export interface Group {
    // (undocumented)
    name?: string;
    // (undocumented)
    type: "group";
}

// @public
export interface InnerTextInputQuestion extends UserInputQuestion {
    default?: string | LocalFunc<string | undefined>;
    password?: boolean;
    // (undocumented)
    type: "innerText";
    validation?: StringValidation | FuncValidation<string>;
    value?: string;
}

// @public
export interface InputResult<T> {
    result?: T;
    type: "success" | "skip" | "back";
}

// @public (undocumented)
export interface Inputs extends Record<string, any> {
    // (undocumented)
    correlationId?: string;
    // (undocumented)
    nonInteractive?: boolean;
    // (undocumented)
    platform: Platform;
    // (undocumented)
    projectId?: string;
    // (undocumented)
    projectPath?: string;
}

// @public (undocumented)
export type InputsWithProjectPath = Inputs & {
    projectPath: string;
};

// @public
export interface InputTextConfig extends UIConfig<string> {
    additionalValidationOnAccept?: (input: string) => string | undefined | Promise<string | undefined>;
    // (undocumented)
    default?: string | (() => Promise<string>);
    password?: boolean;
}

// @public (undocumented)
export type InputTextResult = InputResult<string>;

// @public (undocumented)
export interface IProgressHandler {
    end: (success: boolean, hideAfterFinish?: boolean) => Promise<void>;
    next: (detail?: string) => Promise<void>;
    start: (detail?: string) => Promise<void>;
}

// @public (undocumented)
export interface IQTreeNode {
    // (undocumented)
    children?: IQTreeNode[];
    cliOptionDisabled?: "self" | "children" | "all";
    // (undocumented)
    condition?: StringValidation | StringArrayValidation | ConditionFunc;
    // (undocumented)
    data: Question | Group;
    inputsDisabled?: "self" | "children" | "all";
}

// @public (undocumented)
export const LocalEnvironmentName = "local";

// @public
export type LocalFunc<T> = (inputs: Inputs) => T | Promise<T>;

// @public (undocumented)
export type LoginStatus = {
    status: string;
    token?: string;
    accountInfo?: Record<string, unknown>;
};

// @public (undocumented)
export enum LogLevel {
    Debug = 1,
    Error = 5,
    Info = 3,
    Verbose = 2,
    Warning = 4
}

// @public (undocumented)
export interface LogProvider {
    debug(message: string): void;
    error(message: string): void;
    getLogFilePath(): string;
    info(message: string): void;
    info(message: Array<{
        content: string;
        color: Colors;
    }>): void;
    log(logLevel: LogLevel, message: string): void;
    logInFile(logLevel: LogLevel, message: string): Promise<void>;
    verbose(message: string): void;
    warning(message: string): void;
}

// @public
export interface M365TokenProvider {
    getAccessToken(tokenRequest: TokenRequest): Promise<Result<string, FxError>>;
    getJsonObject(tokenRequest: TokenRequest): Promise<Result<Record<string, unknown>, FxError>>;
    getStatus(tokenRequest: TokenRequest): Promise<Result<LoginStatus, FxError>>;
    removeStatusChangeMap(name: string): Promise<Result<boolean, FxError>>;
    setStatusChangeMap(name: string, tokenRequest: TokenRequest, statusChange: (status: string, token?: string, accountInfo?: Record<string, unknown>) => Promise<void>, immediateCall?: boolean): Promise<Result<boolean, FxError>>;
}

// @public (undocumented)
export type ManifestCapability = {
    name: "staticTab";
    snippet?: IStaticTab;
    existingApp?: boolean;
} | {
    name: "configurableTab";
    snippet?: IConfigurableTab;
    existingApp?: boolean;
} | {
    name: "Bot";
    snippet?: IBot;
    existingApp?: boolean;
} | {
    name: "MessageExtension";
    snippet?: IComposeExtension;
    existingApp?: boolean;
} | {
    name: "WebApplicationInfo";
    snippet?: IWebApplicationInfo;
    existingApp?: boolean;
};

// @public (undocumented)
export const ManifestTemplateFileName = "manifest.json";

// @public (undocumented)
export type MaybePromise<T> = T | Promise<T>;

// @public (undocumented)
export interface MultiFileQuestion extends UserInputQuestion {
    default?: string | LocalFunc<string | undefined>;
    // (undocumented)
    type: "multiFile";
    validation?: FuncValidation<string[]>;
    value?: string[];
}

// @public
export interface MultiSelectConfig extends UIConfig<string[]> {
    // (undocumented)
    default?: string[] | (() => Promise<string[]>);
    onDidChangeSelection?: OnSelectionChangeFunc;
    options: StaticOptions | (() => Promise<StaticOptions>);
    returnObject?: boolean;
    skipSingleOption?: boolean;
}

// @public
export interface MultiSelectQuestion extends UserInputQuestion {
    cliChoiceListCommand?: string;
    default?: string[] | LocalFunc<string[] | undefined>;
    dynamicOptions?: DynamicOptions;
    onDidChangeSelection?: OnSelectionChangeFunc;
    returnObject?: boolean;
    skipSingleOption?: boolean;
    skipValidation?: boolean;
    staticOptions: StaticOptions;
    // (undocumented)
    type: "multiSelect";
    validation?: StringArrayValidation | FuncValidation<string[]>;
    value?: string[] | OptionItem[];
}

// @public (undocumented)
export type MultiSelectResult = InputResult<StaticOptions>;

// @public (undocumented)
export type OnSelectionChangeFunc = (currentSelectedIds: Set<string>, previousSelectedIds: Set<string>) => Promise<Set<string>>;

// @public (undocumented)
export enum OpenAIManifestAuthType {
    // (undocumented)
    None = "none",
    // (undocumented)
    OAuth = "oauth",
    // (undocumented)
    ServiceHttp = "service_http",
    // (undocumented)
    UserHttp = "user_http"
}

// @public (undocumented)
export interface OpenAIPluginManifest {
    // (undocumented)
    api: {
        type: string;
        url: string;
    };
    // (undocumented)
    auth: {
        type: OpenAIManifestAuthType;
    };
    // (undocumented)
    contact_email: string;
    // (undocumented)
    description_for_human: string;
    // (undocumented)
    description_for_model: string;
    // (undocumented)
    legal_info_url: string;
    // (undocumented)
    logo_url: string;
    // (undocumented)
    name_for_human: string;
    // (undocumented)
    name_for_model: string;
    // (undocumented)
    schema_version: string;
}

// @public
export interface OptionItem {
    buttons?: {
        iconPath: string;
        tooltip: string;
        command: string;
    }[];
    // @deprecated (undocumented)
    cliName?: string;
    data?: unknown;
    description?: string;
    detail?: string;
    groupName?: string;
    id: string;
    label: string;
}

// @public (undocumented)
export type OptionValue = string | boolean | string[] | undefined;

// @public
export interface PermissionRequestProvider {
    checkPermissionRequest(): Promise<Result<undefined, FxError>>;
    getPermissionRequest(): Promise<Result<string, FxError>>;
}

// @public
export enum Platform {
    // (undocumented)
    CLI = "cli",
    // (undocumented)
    CLI_HELP = "cli_help",
    // (undocumented)
    VS = "vs",
    // (undocumented)
    VSCode = "vsc"
}

// @public (undocumented)
export const ProductName = "teamsfx";

// @public
export class QTreeNode implements IQTreeNode {
    constructor(data: Question | Group);
    // (undocumented)
    addChild(node: QTreeNode): QTreeNode;
    // (undocumented)
    children?: QTreeNode[];
    cliOptionDisabled?: "self" | "children" | "all";
    // (undocumented)
    condition?: StringValidation | StringArrayValidation | ConditionFunc;
    // (undocumented)
    data: Question | Group;
    inputsDisabled?: "self" | "children" | "all";
    trim(): QTreeNode | undefined;
    // (undocumented)
    validate(): boolean;
}

// @public (undocumented)
export type Question = SingleSelectQuestion | MultiSelectQuestion | TextInputQuestion | SingleFileQuestion | MultiFileQuestion | FolderQuestion | SingleFileQuestion | SingleFileOrInputQuestion;

// @public
export type SelectFileConfig = UIConfig<string> & {
    filters?: {
        [name: string]: string[];
    };
    default?: string | (() => Promise<string>);
    possibleFiles?: {
        id: string;
        label: string;
        description?: string;
    }[];
};

// @public (undocumented)
export type SelectFileResult = InputResult<string>;

// @public
export type SelectFilesConfig = UIConfig<string[]> & {
    filters?: {
        [name: string]: string[];
    };
    default?: string[] | (() => Promise<string[]>);
};

// @public (undocumented)
export type SelectFilesResult = InputResult<string[]>;

// @public
export type SelectFolderConfig = UIConfig<string> & {
    default?: string | (() => Promise<string>);
};

// @public (undocumented)
export type SelectFolderResult = InputResult<string>;

// @public
export interface Settings {
    // (undocumented)
    trackingId: string;
    // (undocumented)
    version: string;
}

// @public (undocumented)
export const SettingsFolderName = "teamsfx";

// @public (undocumented)
export interface SingleFileOrInputConfig extends UIConfig<string> {
    filters?: {
        [name: string]: string[];
    };
    inputBoxConfig: UIConfig<string>;
    inputOptionItem: OptionItem;
}

// @public (undocumented)
export interface SingleFileOrInputQuestion extends UserInputQuestion {
    filters?: {
        [name: string]: string[];
    };
    inputBoxConfig: InnerTextInputQuestion;
    inputOptionItem: OptionItem;
    // (undocumented)
    type: "singleFileOrText";
}

// @public
export interface SingleFileQuestion extends UserInputQuestion {
    default?: string | LocalFunc<string | undefined>;
    filters?: {
        [name: string]: string[];
    };
    // (undocumented)
    type: "singleFile";
    validation?: FuncValidation<string>;
    value?: string;
}

// @public
export interface SingleSelectConfig extends UIConfig<string> {
    // (undocumented)
    default?: string | (() => Promise<string>);
    options: StaticOptions | (() => Promise<StaticOptions>);
    returnObject?: boolean;
    skipSingleOption?: boolean;
}

// @public
export interface SingleSelectQuestion extends UserInputQuestion {
    cliChoiceListCommand?: string;
    default?: string | LocalFunc<string | undefined>;
    dynamicOptions?: DynamicOptions;
    returnObject?: boolean;
    skipSingleOption?: boolean;
    skipValidation?: boolean;
    staticOptions: StaticOptions;
    // (undocumented)
    type: "singleSelect";
    value?: string | OptionItem;
}

// @public (undocumented)
export type SingleSelectResult = InputResult<string | OptionItem>;

// @public (undocumented)
export enum Stage {
    // (undocumented)
    addCapability = "addCapability",
    // (undocumented)
    addCiCdFlow = "addCiCdFlow",
    // (undocumented)
    addFeature = "addFeature",
    // (undocumented)
    addResource = "addResource",
    // (undocumented)
    addWebpart = "addWebpart",
    // (undocumented)
    build = "build",
    // (undocumented)
    buildAad = "buildAad",
    // (undocumented)
    checkPermission = "checkPermission",
    // (undocumented)
    copilotPluginAddAPI = "copilotPluginAddAPI",
    // (undocumented)
    create = "create",
    // (undocumented)
    createAppPackage = "createAppPackage",
    // (undocumented)
    createEnv = "createEnv",
    // (undocumented)
    debug = "debug",
    // (undocumented)
    deploy = "deploy",
    // (undocumented)
    deployAad = "deployAad",
    // (undocumented)
    deployTeams = "deployTeams",
    // (undocumented)
    getProjectConfig = "getProjectConfig",
    // (undocumented)
    getQuestions = "getQuestions",
    // (undocumented)
    grantPermission = "grantPermission",
    // (undocumented)
    initDebug = "initDebug",
    // (undocumented)
    initInfra = "initInfra",
    // (undocumented)
    listCollaborator = "listCollaborator",
    // (undocumented)
    listEnv = "listEnv",
    // (undocumented)
    package = "package",
    // (undocumented)
    previewWithManifest = "previewWithManifest",
    // (undocumented)
    provision = "provision",
    // (undocumented)
    publish = "publish",
    // (undocumented)
    publishInDeveloperPortal = "publishInDeveloperPortal",
    // (undocumented)
    removeEnv = "removeEnv",
    // (undocumented)
    switchEnv = "switchEnv",
    // (undocumented)
    update = "update",
    // (undocumented)
    userTask = "userTask",
    // (undocumented)
    validateApplication = "validateApplication"
}

// @public
export type StaticOptions = string[] | OptionItem[];

// @public (undocumented)
export const StaticPlatforms: Platform[];

// @public
export interface StaticValidation {
    equals?: unknown;
    required?: boolean;
}

// @public
export interface StringArrayValidation extends StaticValidation {
    contains?: string;
    containsAll?: string[];
    containsAny?: string[];
    enum?: string[];
    equals?: string[];
    excludes?: string;
    maxItems?: number;
    minItems?: number;
    uniqueItems?: boolean;
}

// @public
export interface StringValidation extends StaticValidation {
    endsWith?: string;
    enum?: string[];
    equals?: string;
    excludesEnum?: string[];
    includes?: string;
    maxLength?: number;
    minLength?: number;
    notEquals?: string;
    pattern?: string;
    startsWith?: string;
}

// @public (undocumented)
export type SubscriptionInfo = {
    subscriptionName: string;
    subscriptionId: string;
    tenantId: string;
};

// @public
export class SystemError extends Error implements FxError {
    constructor(opt: SystemErrorOptions);
    constructor(source: string, name: string, message: string, displayMessage?: string);
    // (undocumented)
    categories?: string[];
    displayMessage?: string;
    innerError?: any;
    issueLink?: string;
    source: string;
    timestamp: Date;
    userData?: string;
}

// @public (undocumented)
export interface SystemErrorOptions extends ErrorOptionBase {
    // (undocumented)
    issueLink?: string;
}

// @public (undocumented)
export enum TelemetryEvent {
    // (undocumented)
    askQuestion = "askQuestion"
}

// @public (undocumented)
export enum TelemetryProperty {
    // (undocumented)
    answer = "answer",
    // (undocumented)
    answerType = "answerType",
    // (undocumented)
    platform = "platform",
    // (undocumented)
    question = "question",
    // (undocumented)
    stage = "stage"
}

// @public
export interface TelemetryReporter {
    sendTelemetryErrorEvent(eventName: string, properties?: {
        [key: string]: string;
    }, measurements?: {
        [key: string]: number;
    }, errorProps?: string[]): void;
    sendTelemetryEvent(eventName: string, properties?: {
        [key: string]: string;
    }, measurements?: {
        [key: string]: number;
    }): void;
    sendTelemetryException(error: Error, properties?: {
        [key: string]: string;
    }, measurements?: {
        [key: string]: number;
    }): void;
}

// @public (undocumented)
export const TemplateFolderName = "templates";

// @public
export interface TextInputQuestion extends UserInputQuestion {
    additionalValidationOnAccept?: StringValidation | FuncValidation<string>;
    default?: string | LocalFunc<string | undefined>;
    password?: boolean;
    // (undocumented)
    type: "text";
    validation?: StringValidation | FuncValidation<string>;
    value?: string;
}

// @public (undocumented)
export type TokenProvider = {
    azureAccountProvider: AzureAccountProvider;
    m365TokenProvider: M365TokenProvider;
};

// @public (undocumented)
export type TokenRequest = {
    scopes: Array<string>;
    showDialog?: boolean;
};

// @public (undocumented)
export interface Tools {
    // (undocumented)
    cryptoProvider?: CryptoProvider;
    // (undocumented)
    expServiceProvider?: ExpServiceProvider;
    // (undocumented)
    logProvider: LogProvider;
    // (undocumented)
    permissionRequest?: PermissionRequestProvider;
    // (undocumented)
    telemetryReporter?: TelemetryReporter;
    // (undocumented)
    tokenProvider: TokenProvider;
    // (undocumented)
    treeProvider?: TreeProvider;
    // (undocumented)
    ui: UserInteraction;
}

// @public (undocumented)
export enum TreeCategory {
    // (undocumented)
    Account = 1,
    // (undocumented)
    Environment = 5,
    // (undocumented)
    Feedback = 2,
    // (undocumented)
    GettingStarted = 0,
    // (undocumented)
    Project = 3,
    // (undocumented)
    Provision = 4
}

// @public (undocumented)
export interface TreeItem {
    // (undocumented)
    callback?: (args: any) => Promise<Result<null, FxError>>;
    // (undocumented)
    commandId: string;
    // (undocumented)
    contextValue?: string;
    // (undocumented)
    description?: string;
    // (undocumented)
    expanded?: boolean;
    // (undocumented)
    icon?: string;
    // (undocumented)
    isCustom?: boolean;
    // (undocumented)
    label: string;
    // (undocumented)
    parent?: TreeCategory | string;
    // (undocumented)
    subTreeItems?: TreeItem[];
    // (undocumented)
    tooltip?: {
        value: string;
        isMarkdown: boolean;
    };
}

// @public (undocumented)
export interface TreeProvider {
    // (undocumented)
    add: (tree: TreeItem[]) => Promise<Result<null, FxError>>;
    // (undocumented)
    refresh: (tree: TreeItem[]) => Promise<Result<null, FxError>>;
    // (undocumented)
    remove: (tree: TreeItem[]) => Promise<Result<null, FxError>>;
}

// @public
export interface UIConfig<T> {
    buttons?: {
        icon: string;
        tooltip: string;
        command: string;
    }[];
    default?: T | (() => Promise<T>);
    name: string;
    placeholder?: string;
    prompt?: string;
    step?: number;
    title: string;
    totalSteps?: number;
    validation?: (input: T) => string | undefined | Promise<string | undefined>;
}

// @public
export class UserError extends Error implements FxError {
    constructor(opt: UserErrorOptions);
    constructor(source: string, name: string, message: string, displayMessage?: string);
    // (undocumented)
    categories?: string[];
    displayMessage?: string;
    helpLink?: string;
    innerError?: any;
    source: string;
    timestamp: Date;
    userData?: string;
}

// @public (undocumented)
export interface UserErrorOptions extends ErrorOptionBase {
    // (undocumented)
    helpLink?: string;
}

// @public
export interface UserInputQuestion extends BaseQuestion {
    alternativeNames?: string[];
    // (undocumented)
    cliDescription?: string;
    cliHidden?: boolean;
    cliName?: string;
    cliShortName?: string;
    cliType?: "option" | "argument";
    default?: string | string[] | LocalFunc<string | string[] | undefined>;
    isBoolean?: boolean;
    placeholder?: string | LocalFunc<string | undefined>;
    prompt?: string | LocalFunc<string | undefined>;
    required?: boolean;
    title: string | LocalFunc<string | undefined>;
    type: "singleSelect" | "multiSelect" | "singleFile" | "multiFile" | "folder" | "text" | "singleFileOrText" | "innerText";
    validation?: ValidationSchema;
    validationHelp?: string;
}

// @public
export interface UserInteraction {
    createProgressBar: (title: string, totalSteps: number) => IProgressHandler;
    executeFunction?(config: ExecuteFuncConfig): any | Promise<any>;
    inputText: (config: InputTextConfig) => Promise<Result<InputTextResult, FxError>>;
    openFile?(filePath: string): Promise<Result<boolean, FxError>>;
    openUrl(link: string): Promise<Result<boolean, FxError>>;
    reload?(): Promise<Result<boolean, FxError>>;
    runCommand?(args: {
        cmd: string;
        workingDirectory?: string;
        shell?: string;
        timeout?: number;
        env?: {
            [k: string]: string;
        };
    }): Promise<Result<string, FxError>>;
    selectFile: (config: SelectFileConfig) => Promise<Result<SelectFileResult, FxError>>;
    selectFileOrInput?(config: SingleFileOrInputConfig): Promise<Result<InputResult<string>, FxError>>;
    selectFiles: (config: SelectFilesConfig) => Promise<Result<SelectFilesResult, FxError>>;
    selectFolder: (config: SelectFolderConfig) => Promise<Result<SelectFolderResult, FxError>>;
    selectOption: (config: SingleSelectConfig) => Promise<Result<SingleSelectResult, FxError>>;
    selectOptions: (config: MultiSelectConfig) => Promise<Result<MultiSelectResult, FxError>>;
    showMessage(level: "info" | "warn" | "error", message: string, modal: boolean, ...items: string[]): Promise<Result<string | undefined, FxError>>;
    showMessage(level: "info" | "warn" | "error", message: Array<{
        content: string;
        color: Colors;
    }>, modal: boolean, ...items: string[]): Promise<Result<string | undefined, FxError>>;
}

// @public
export function validate<T extends string | string[] | OptionItem | OptionItem[] | undefined>(validSchema: ValidationSchema | ConditionFunc, value: T, inputs?: Inputs): Promise<string | undefined>;

// @public (undocumented)
export type ValidateFunc<T> = (input: T, inputs?: Inputs) => string | undefined | Promise<string | undefined>;

// @public
export type ValidationSchema = StringValidation | StringArrayValidation | FuncValidation<any>;

// @public (undocumented)
export type Void = {};

// @public (undocumented)
export const Void: {};

// @public (undocumented)
export enum VsCodeEnv {
    // (undocumented)
    codespaceBrowser = "codespaceBrowser",
    // (undocumented)
    codespaceVsCode = "codespaceVsCode",
    // (undocumented)
    local = "local",
    // (undocumented)
    remote = "remote"
}

// @public (undocumented)
export interface Warning {
    // (undocumented)
    content: string;
    // (undocumented)
    type: string;
}


export * from "@microsoft/teams-manifest";
export * from "neverthrow";

// (No @packageDocumentation comment for this package)

```
