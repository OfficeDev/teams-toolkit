## API Report File for "@microsoft/teamsfx"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference types="node" />

import { AccessToken } from '@azure/identity';
import { Activity } from 'botbuilder';
import { Attachment } from 'botbuilder';
import { AxiosInstance } from 'axios';
import { AxiosRequestConfig } from 'axios';
import { CardAction } from 'botbuilder';
import { CardImage } from 'botbuilder';
import { ChannelInfo } from 'botbuilder';
import { CloudAdapter } from 'botbuilder';
import { ComponentDialog } from 'botbuilder-dialogs';
import { ConversationReference } from 'botbuilder';
import { ConversationState } from 'botbuilder';
import { Dialog } from 'botbuilder-dialogs';
import { DialogContext } from 'botbuilder-dialogs';
import { DialogTurnResult } from 'botbuilder-dialogs';
import { GetTokenOptions } from '@azure/identity';
import { HeroCard } from 'botbuilder';
import { InvokeResponse } from 'botbuilder';
import { MessagingExtensionResponse } from 'botbuilder';
import { O365ConnectorCard } from 'botbuilder';
import { ReceiptCard } from 'botbuilder';
import { Request as Request_2 } from 'botbuilder';
import { Response as Response_2 } from 'botbuilder';
import { SecureContextOptions } from 'tls';
import { SigninStateVerificationQuery } from 'botbuilder';
import { StatePropertyAccessor } from 'botbuilder';
import { StatusCodes } from 'botbuilder';
import { Storage as Storage_2 } from 'botbuilder';
import { TeamDetails } from 'botbuilder';
import { TeamsChannelAccount } from 'botbuilder';
import { ThumbnailCard } from 'botbuilder';
import { TokenCredential } from '@azure/identity';
import { TokenResponse } from 'botframework-schema';
import { TurnContext } from 'botbuilder';
import { UserState } from 'botbuilder';

// @public
export enum AdaptiveCardResponse {
    NewForAll = 2,
    ReplaceForAll = 1,
    ReplaceForInteractor = 0
}

// @public
export enum ApiKeyLocation {
    Header = 0,
    QueryParams = 1
}

// @public
export class ApiKeyProvider implements AuthProvider {
    constructor(keyName: string, keyValue: string, keyLocation: ApiKeyLocation);
    AddAuthenticationInfo(config: AxiosRequestConfig): Promise<AxiosRequestConfig>;
}

// @public
export class AppCredential implements TokenCredential {
    constructor(authConfig: AppCredentialAuthConfig);
    getToken(scopes: string | string[], options?: GetTokenOptions): Promise<AccessToken | null>;
}

// @public
export type AppCredentialAuthConfig = OnBehalfOfCredentialAuthConfig;

// @public
export interface AuthProvider {
    AddAuthenticationInfo: (config: AxiosRequestConfig) => Promise<AxiosRequestConfig>;
}

export { AxiosInstance }

// @public
export class BasicAuthProvider implements AuthProvider {
    constructor(userName: string, password: string);
    AddAuthenticationInfo(config: AxiosRequestConfig): Promise<AxiosRequestConfig>;
}

// @public
export class BearerTokenAuthProvider implements AuthProvider {
    constructor(getToken: () => Promise<string>);
    AddAuthenticationInfo(config: AxiosRequestConfig): Promise<AxiosRequestConfig>;
}

declare namespace BotBuilderCloudAdapter {
    export {
        ConversationOptions,
        NotificationOptions_2 as NotificationOptions,
        ConversationBot,
        BotSsoExecutionDialog,
        Channel,
        Member,
        NotificationBot,
        sendAdaptiveCard,
        sendMessage,
        TeamsBotInstallation,
        SearchScope,
        CommandBot,
        CardActionBot
    }
}
export { BotBuilderCloudAdapter }

// @public
export interface BotSsoConfig {
    aad: {
        scopes: string[];
    } & OnBehalfOfCredentialAuthConfig & {
        initiateLoginEndpoint: string;
    };
    // (undocumented)
    dialog?: {
        CustomBotSsoExecutionActivityHandler?: new (ssoConfig: BotSsoConfig) => BotSsoExecutionActivityHandler;
        conversationState?: ConversationState;
        userState?: UserState;
        dedupStorage?: Storage_2;
        ssoPromptConfig?: {
            timeout?: number;
            endOnInvalidMessage?: boolean;
        };
    };
}

// @public
export interface BotSsoExecutionActivityHandler {
    addCommand(handler: BotSsoExecutionDialogHandler, triggerPatterns: TriggerPatterns): void;
    handleTeamsSigninTokenExchange(context: TurnContext, query: SigninStateVerificationQuery): Promise<void>;
    handleTeamsSigninVerifyState(context: TurnContext, query: SigninStateVerificationQuery): Promise<void>;
    run(context: TurnContext): Promise<void>;
}

// @public
export class BotSsoExecutionDialog extends ComponentDialog {
    constructor(dedupStorage: Storage_2, ssoPromptSettings: TeamsBotSsoPromptSettings, authConfig: OnBehalfOfCredentialAuthConfig, initiateLoginEndpoint: string, dialogName?: string);
    addCommand(handler: BotSsoExecutionDialogHandler, triggerPatterns: TriggerPatterns): void;
    protected onEndDialog(context: TurnContext): Promise<void>;
    run(context: TurnContext, accessor: StatePropertyAccessor): Promise<void>;
}

// @public (undocumented)
export type BotSsoExecutionDialogHandler = (context: TurnContext, tokenResponse: TeamsBotSsoPromptTokenResponse, message: CommandMessage) => Promise<void>;

// @public
class CardActionBot {
    constructor(adapter: CloudAdapter, options?: CardActionOptions);
    registerHandler(actionHandler: TeamsFxAdaptiveCardActionHandler): void;
    registerHandlers(actionHandlers: TeamsFxAdaptiveCardActionHandler[]): void;
}

// @public
export interface CardActionOptions {
    actions?: TeamsFxAdaptiveCardActionHandler[];
}

// @public
export class CertificateAuthProvider implements AuthProvider {
    constructor(certOption: SecureContextOptions);
    AddAuthenticationInfo(config: AxiosRequestConfig): Promise<AxiosRequestConfig>;
}

// @public
class Channel implements NotificationTarget {
    constructor(parent: TeamsBotInstallation, info: ChannelInfo);
    readonly info: ChannelInfo;
    readonly parent: TeamsBotInstallation;
    sendAdaptiveCard(card: unknown, onError?: (context: TurnContext, error: Error) => Promise<void>): Promise<MessageResponse>;
    // Warning: (ae-forgotten-export) The symbol "MessageResponse" needs to be exported by the entry point index.d.ts
    sendMessage(text: string, onError?: (context: TurnContext, error: Error) => Promise<void>): Promise<MessageResponse>;
    readonly type: NotificationTargetType;
}

// @public
class CommandBot {
    constructor(adapter: CloudAdapter, options?: CommandOptions, ssoCommandActivityHandler?: BotSsoExecutionActivityHandler, ssoConfig?: BotSsoConfig);
    registerCommand(command: TeamsFxBotCommandHandler): void;
    registerCommands(commands: TeamsFxBotCommandHandler[]): void;
    registerSsoCommand(ssoCommand: TeamsFxBotSsoCommandHandler): void;
    registerSsoCommands(ssoCommands: TeamsFxBotSsoCommandHandler[]): void;
}

// @public
export interface CommandMessage {
    matches?: RegExpMatchArray;
    text: string;
}

// @public
export interface CommandOptions {
    commands?: TeamsFxBotCommandHandler[];
    ssoCommands?: TeamsFxBotSsoCommandHandler[];
}

// @public
class ConversationBot {
    constructor(options: ConversationOptions);
    readonly adapter: CloudAdapter;
    readonly cardAction?: CardActionBot;
    readonly command?: CommandBot;
    readonly notification?: NotificationBot;
    requestHandler(req: Request_2, res: Response_2, logic?: (context: TurnContext) => Promise<any>): Promise<void>;
}

// @public
interface ConversationOptions {
    adapter?: CloudAdapter;
    adapterConfig?: {
        [key: string]: unknown;
    };
    cardAction?: CardActionOptions & {
        enabled?: boolean;
    };
    command?: CommandOptions & {
        enabled?: boolean;
    };
    notification?: NotificationOptions_2 & {
        enabled?: boolean;
    };
    ssoConfig?: BotSsoConfig;
}

// @public
export interface ConversationReferenceStore {
    add(key: string, reference: Partial<ConversationReference>, options: ConversationReferenceStoreAddOptions): Promise<boolean>;
    list(pageSize?: number, continuationToken?: string): Promise<PagedData<Partial<ConversationReference>>>;
    remove(key: string, reference: Partial<ConversationReference>): Promise<boolean>;
}

// @public
export interface ConversationReferenceStoreAddOptions {
    overwrite?: boolean;
}

// @public
export function createApiClient(apiEndpoint: string, authProvider: AuthProvider): AxiosInstance;

// @public
export function createPemCertOption(cert: string | Buffer, key: string | Buffer, options?: {
    passphrase?: string;
    ca?: string | Buffer;
}): SecureContextOptions;

// @public
export function createPfxCertOption(pfx: string | Buffer, options?: {
    passphrase?: string;
}): SecureContextOptions;

// @public
export enum ErrorCode {
    AuthorizationInfoAlreadyExists = "AuthorizationInfoAlreadyExists",
    CannotFindCommand = "CannotFindCommand",
    ChannelNotSupported = "ChannelNotSupported",
    ConsentFailed = "ConsentFailed",
    FailedOperation = "FailedOperation",
    FailedToProcessSsoHandler = "FailedToProcessSsoHandler",
    FailedToRetrieveSsoToken = "FailedToRetrieveSsoToken",
    FailedToRunDedupStep = "FailedToRunDedupStep",
    FailedToRunSsoStep = "FailedToRunSsoStep",
    InternalError = "InternalError",
    InvalidCertificate = "InvalidCertificate",
    InvalidConfiguration = "InvalidConfiguration",
    InvalidParameter = "InvalidParameter",
    InvalidResponse = "InvalidResponse",
    RuntimeNotSupported = "RuntimeNotSupported",
    ServiceError = "ServiceError",
    SsoActivityHandlerIsUndefined = "SsoActivityHandlerIsUndefined",
    TokenExpiredError = "TokenExpiredError",
    UiRequiredError = "UiRequiredError"
}

// @public
export class ErrorWithCode extends Error {
    constructor(message?: string, code?: ErrorCode);
    code: string | undefined;
}

// @public
export function getLogLevel(): LogLevel | undefined;

// @public (undocumented)
export interface GetTeamsUserTokenOptions extends GetTokenOptions {
    // (undocumented)
    resources?: string[];
}

// @public
export function handleMessageExtensionLinkQueryWithSSO(context: TurnContext, config: OnBehalfOfCredentialAuthConfig, initiateLoginEndpoint: string, scopes: string | string[], logic: (token: MessageExtensionTokenResponse) => Promise<any>): Promise<void | MessagingExtensionResponse>;

// @public
export function handleMessageExtensionQueryWithSSO(context: TurnContext, config: OnBehalfOfCredentialAuthConfig, initiateLoginEndpoint: string, scopes: string | string[], logic: (token: MessageExtensionTokenResponse) => Promise<any>): Promise<void | MessagingExtensionResponse>;

// @public
export enum InvokeResponseErrorCode {
    BadRequest = 400,
    InternalServerError = 500
}

// @public
export class InvokeResponseFactory {
    static adaptiveCard(card: unknown): InvokeResponse;
    static createInvokeResponse(statusCode: StatusCodes, body?: unknown): InvokeResponse;
    static errorResponse(errorCode: InvokeResponseErrorCode, errorMessage: string): InvokeResponse;
    static textMessage(message: string): InvokeResponse;
}

// @public
export type LogFunction = (level: LogLevel, message: string) => void;

// @public
export interface Logger {
    error(message: string): void;
    info(message: string): void;
    verbose(message: string): void;
    warn(message: string): void;
}

// @public
export enum LogLevel {
    Error = 3,
    Info = 1,
    Verbose = 0,
    Warn = 2
}

// @public
class Member implements NotificationTarget {
    constructor(parent: TeamsBotInstallation, account: TeamsChannelAccount);
    readonly account: TeamsChannelAccount;
    readonly parent: TeamsBotInstallation;
    sendAdaptiveCard(card: unknown, onError?: (context: TurnContext, error: Error) => Promise<void>): Promise<MessageResponse>;
    sendMessage(text: string, onError?: (context: TurnContext, error: Error) => Promise<void>): Promise<MessageResponse>;
    readonly type: NotificationTargetType;
}

// @public
export class MessageBuilder {
    static attachAdaptiveCard<TData extends object>(cardTemplate: unknown, data: TData): Partial<Activity>;
    static attachAdaptiveCardWithoutData(card: unknown): Partial<Activity>;
    static attachContent(attachement: Attachment): Partial<Activity>;
    static attachHeroCard(title: string, images?: (CardImage | string)[], buttons?: (CardAction | string)[], other?: Partial<HeroCard>): Partial<Activity>;
    static attachO365ConnectorCard(card: O365ConnectorCard): Partial<Activity>;
    static AttachReceiptCard(card: ReceiptCard): Partial<Activity>;
    static attachSigninCard(title: string, url: string, text?: string): Partial<Activity>;
    // (undocumented)
    static attachThumbnailCard(title: string, images?: (CardImage | string)[], buttons?: (CardAction | string)[], other?: Partial<ThumbnailCard>): Partial<Activity>;
}

// @public
export interface MessageExtensionTokenResponse extends TokenResponse {
    ssoToken: string;
    ssoTokenExpiration: string;
}

// @public
class NotificationBot {
    constructor(adapter: CloudAdapter, options?: NotificationOptions_2);
    buildTeamsBotInstallation(conversationReference: Partial<ConversationReference>): TeamsBotInstallation | null;
    findAllChannels(predicate: (channel: Channel, teamDetails: TeamDetails | undefined) => Promise<boolean>): Promise<Channel[]>;
    findAllMembers(predicate: (member: Member) => Promise<boolean>, scope?: SearchScope): Promise<Member[]>;
    findChannel(predicate: (channel: Channel, teamDetails: TeamDetails | undefined) => Promise<boolean>): Promise<Channel | undefined>;
    findMember(predicate: (member: Member) => Promise<boolean>, scope?: SearchScope): Promise<Member | undefined>;
    getPagedInstallations(pageSize?: number, continuationToken?: string, validationEnabled?: boolean): Promise<PagedData<TeamsBotInstallation>>;
    validateInstallation(conversationReference: Partial<ConversationReference>): Promise<boolean>;
}

// @public
interface NotificationOptions_2 {
    botAppId?: string;
    store?: ConversationReferenceStore;
}

// @public
export interface NotificationTarget {
    sendAdaptiveCard(card: unknown, onError?: (context: TurnContext, error: Error) => Promise<void>): Promise<MessageResponse>;
    sendMessage(text: string, onError?: (context: TurnContext, error: Error) => Promise<void>): Promise<MessageResponse>;
    readonly type?: NotificationTargetType;
}

// @public
export enum NotificationTargetType {
    Channel = "Channel",
    Group = "Group",
    Person = "Person"
}

// @public
export type OnBehalfOfCredentialAuthConfig = {
    authorityHost: string;
    clientId: string;
    tenantId: string;
} & ({
    clientSecret: string;
    certificateContent?: never;
} | {
    clientSecret?: never;
    certificateContent: string;
});

// @public
export class OnBehalfOfUserCredential implements TokenCredential {
    constructor(ssoToken: string, config: OnBehalfOfCredentialAuthConfig);
    getToken(scopes: string | string[], options?: GetTokenOptions): Promise<AccessToken | null>;
    getUserInfo(): UserInfo;
}

// @public
export interface PagedData<T> {
    continuationToken?: string;
    data: T[];
}

// @public
enum SearchScope {
    All = 7,
    Channel = 4,
    Group = 2,
    Person = 1
}

// @public
function sendAdaptiveCard(target: NotificationTarget, card: unknown, onError?: (context: TurnContext, error: Error) => Promise<void>): Promise<MessageResponse>;

// @public
function sendMessage(target: NotificationTarget, text: string, onError?: (context: TurnContext, error: Error) => Promise<void>): Promise<MessageResponse>;

// @public
export function setLogFunction(logFunction?: LogFunction): void;

// @public
export function setLogger(logger?: Logger): void;

// @public
export function setLogLevel(level: LogLevel): void;

// @public
class TeamsBotInstallation implements NotificationTarget {
    constructor(adapter: CloudAdapter, conversationReference: Partial<ConversationReference>, botAppId: string);
    readonly adapter: CloudAdapter;
    readonly botAppId: string;
    channels(): Promise<Channel[]>;
    readonly conversationReference: Partial<ConversationReference>;
    getPagedMembers(pageSize?: number, continuationToken?: string): Promise<PagedData<Member>>;
    getTeamDetails(): Promise<TeamDetails | undefined>;
    sendAdaptiveCard(card: unknown, onError?: (context: TurnContext, error: Error) => Promise<void>): Promise<MessageResponse>;
    sendMessage(text: string, onError?: (context: TurnContext, error: Error) => Promise<void>): Promise<MessageResponse>;
    readonly type?: NotificationTargetType;
}

// @public
export class TeamsBotSsoPrompt extends Dialog {
    constructor(authConfig: OnBehalfOfCredentialAuthConfig, initiateLoginEndpoint: string, dialogId: string, settings: TeamsBotSsoPromptSettings);
    beginDialog(dc: DialogContext): Promise<DialogTurnResult>;
    continueDialog(dc: DialogContext): Promise<DialogTurnResult>;
}

// @public
export interface TeamsBotSsoPromptSettings {
    endOnInvalidMessage?: boolean;
    scopes: string[];
    timeout?: number;
}

// @public
export interface TeamsBotSsoPromptTokenResponse extends TokenResponse {
    ssoToken: string;
    ssoTokenExpiration: string;
}

// @public
export interface TeamsFxAdaptiveCardActionHandler {
    adaptiveCardResponse?: AdaptiveCardResponse;
    handleActionInvoked(context: TurnContext, actionData: any): Promise<InvokeResponse>;
    triggerVerb: string;
}

// @public
export interface TeamsFxBotCommandHandler {
    handleCommandReceived(context: TurnContext, message: CommandMessage): Promise<string | Partial<Activity> | void>;
    triggerPatterns: TriggerPatterns;
}

// @public
export interface TeamsFxBotSsoCommandHandler {
    handleCommandReceived(context: TurnContext, message: CommandMessage, tokenResponse: TeamsBotSsoPromptTokenResponse): Promise<string | Partial<Activity> | void>;
    triggerPatterns: TriggerPatterns;
}

// @public
export class TeamsUserCredential implements TokenCredential {
    constructor(authConfig: TeamsUserCredentialAuthConfig);
    getToken(scopes: string | string[], options?: GetTokenOptions): Promise<AccessToken | null>;
    getUserInfo(resources?: string[]): Promise<UserInfo>;
    login(scopes: string | string[], resources?: string[]): Promise<void>;
}

// @public
export type TeamsUserCredentialAuthConfig = {
    initiateLoginEndpoint: string;
    clientId: string;
};

// @public
export type TriggerPatterns = string | RegExp | (string | RegExp)[];

// @public
export interface UserInfo {
    displayName: string;
    objectId: string;
    preferredUserName: string;
    tenantId: string;
}

// (No @packageDocumentation comment for this package)

```
